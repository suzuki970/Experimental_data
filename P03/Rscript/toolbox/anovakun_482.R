# ???ANOVA?????????????????????????????????????????????????????????????????????????????????????????????????????????
# 1)???????????????????????????????????????R????????????????????????
# 2)????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 3)????????????????????????????????????????????????????????????????????????????????????""???????????????????????????????????????????????????????????????????????????????????????
# ???????????????????????????
# 
# ???????????????
# anovakun?????????????????????????????????????????????????????????????????????????????????????????????
# 1)?????????????????????????????????????????????????????????????????????
# 2)????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 3)????????????????????????????????????????????????????????????????????????????????????a1?????????????????????????????????????????????????????????????????????????????????????????????????????????
# 4)??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 5)???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 6)????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 
# ???AsBC???????????????????????????????????????????????????????????????
# 		b1	b1	b2	b2
# 		c1	c2	c1	c2
# 	------------------------------------
# 	a1	12	9	14	13	---????????????
# 	a1	13	10	14	12	---????????????
# 	a1	11	10	13	15	---????????????
# 	a2	18	12	16	15	---????????????
# 	a2	17	14	15	14	---????????????
# 	a2	15	13	18	15	---????????????
# 
# ????????????????????????????????????????????????x???????????????
# 
# > anovakun(x, "AsBC", 2, 2, 2)
# 
# ???????????????????????????????????????
# 
# ???ABsC?????????????????????????????????????????????????????????????????????
# 			c1	c2
# 	-------------------------------
# 	a1	b1	3.5	4.2	---????????????
# 	a1	b1	2.7	3.2	---????????????
# 	a1	b2	2.5	3.8	---????????????
# 	a1	b3	4.0	3.9	---????????????
# 	a2	b1	3.3	4.0	---????????????
# 	a2	b1	1.4	2.5	---????????????
# 	a2	b2	3.7	4.2	---????????????
# 	a2	b2	2.2	4.2	---????????????
# 	a2	b3	1.3	2.1	---????????????
# 	a2	b3	3.4	3.9	---?????????10
# 
# ????????????????????????????????????????????????x???????????????
# 
# > anovakun(x, "ABsC", 2, 3, 2)
# 
# ???????????????????????????????????????
# 
# ?????????????????????
# 1)long??????long = T????????????????????????????????????????????????????????????????????????
# 2)type2??????type2 = T????????????????????????????????????????????????????????????????????????
# 3)nopost??????nopost = T?????????????????????????????????????????????
# 4)tech??????????????????????????????????????????tech = T?????????????????????????????????????????????????????????????????????????????????????????????
# 5)data.frame??????data.frame = T???????????????????????????????????????????????????????????????????????????????????????dat????????????????????????????????????????????????
# 6)copy??????copy = T?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 7)holm??????holm = T???????????????????????????????????????Holm??????????????????
# 8)hc??????hc = T???????????????????????????????????????Holland-Copenhaver??????????????????
# 9)s2r??????s2r = T???????????????Shaffer??????????????????????????????????????????????????????????????????????????????????????????????????????????????????Rasmussen????????????????????????????????????
# 10)s2d??????s2d = T???????????????Shaffer??????????????????????????????????????????????????????????????????????????????????????????????????????????????????Donoghue????????????????????????????????????
# 11)fs1??????fs1 = T?????????????????????????????????????????????????????????????????????????????????????????????Shaffer??????????????????
# 12)fs2r??????fs2r = T???????????????Shaffer2????????????F-Shaffer1???????????????????????????????????????Shaffer?????????????????????Rasmussen????????????????????????????????????
# 13)fs2d??????fs2d = T???????????????Shaffer2????????????F-Shaffer1???????????????????????????????????????Shaffer?????????????????????Donoghue????????????????????????????????????
# 14)hc, s2r??????hc = T??????s2r = T???????????????fs2r = T???s2d = T???fs2d = T??????????????????Shaffer2?????????????????????Holland-Copenhaver??????????????????
# 15)holm, hc??????holm = T??????hc = T???????????????Holm??????????????????Sidak???????????????????????????????????????Holm-Sidak???????????????
# 16)welch??????welch = T????????????????????????????????????Keselman-Keselman-Shaffer???????????????Welch-Satterthwaite??????????????????????????????
# 17)criteria??????criteria = T??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 18)lb??????lb = T???????????????????????????????????????????????????????????????????????????????????????Lower Bound??????????????????????????????????????????Geisser-Greenhouse?????????????????????
# 19)gg??????gg = T?????????????????????????????????????????????????????????Greehnouse-Geisser??????????????????????????????????????????????????????
# 20)hf??????hf = T?????????????????????????????????????????????????????????Huynh-Feldt??????????????????????????????????????????????????????
# 21)cm??????cm = T?????????????????????????????????????????????????????????Chi-Muller??????????????????????????????????????????????????????
# 22)auto??????auto = T?????????????????????????????????????????????????????????????????????????????????Greehnouse-Geisser??????????????????????????????????????????????????????
# 23)mau??????mau = T??????????????????????????????????????????Mauchly???????????????????????????
# 24)har??????har = T??????????????????????????????????????????Harris????????????????????????????????????
# 25)iga??????iga = T??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 26)ciga??????ciga = T????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 27)eta??????eta = T???????????????????????????????????????????????????????????????
# 28)peta??????peta = T??????????????????????????????????????????????????????????????????
# 29)geta??????geta = T???????????????????????????????????????????????????????????????????????????geta = "??????????????????A, B, C...???"?????????????????????????????????????????????????????????????????????????????????????????????????????????
# ????????????????????????????????????????????????????????????????????????geta = c("A", "C")?????????????????????????????????????????????????????????????????????????????????
# 30)eps??????eps = T?????????????????????????????????????????????????????????????????????
# 31)peps??????peps = T????????????????????????????????????????????????????????????????????????
# 32)geps??????geps = T?????????????????????????????????????????????????????????????????????????????????geps = "??????????????????A, B, C...???"???????????????????????????????????????????????????????????????????????????????????????????????????????????????
# ????????????????????????????????????????????????????????????????????????geps = c("A", "C")?????????????????????????????????????????????????????????????????????????????????
# 33)omega??????omega = T????????????????????????????????????????????????????????????????????????????????????
# 34)omegana??????omegana = T???????????????????????????????????????????????????????????????????????????????????????
# 35)pomega??????pomega = T??????????????????????????????????????????????????????????????????
# 36)gomega??????gomega = T????????????????????????????????????????????????????????????????????????????????????????????????gomega = "??????????????????A, B, C...???"?????????????????????????????????????????????????????????????????????????????????????????????????????????
# ????????????????????????????????????????????????????????????????????????gomega = c("A", "C")?????????????????????????????????????????????????????????????????????????????????
# 37)gomegana??????gomegana = T???????????????????????????????????????????????????????????????????????????????????????????????????gomegana = "??????????????????A, B, C...???"?????????????????????????????????????????????????????????????????????????????????????????????????????????
# ????????????????????????????????????????????????????????????????????????gomegana = c("A", "C")?????????????????????????????????????????????????????????????????????????????????
# 38)prep??????prep = T?????????????????????????????????p_rep???????????????
# 39)nesci??????nesci = T?????????????????????????????????????????????????????????????????????F???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 40)besci??????besci = T?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 41)cilmd??????cilmd = T?????????????????????????????????????????????????????????Loftus-Masson??????????????????????????????
# 42)cilm??????cilm = T???????????????????????????????????????Loftus-Masson??????????????????????????????
# 43)cind??????cind = T?????????????????????????????????????????????????????????????????????????????????????????????????????????
# 44)cin??????cin = T???????????????????????????????????????????????????????????????????????????????????????
# 45)ciml??????ciml = T????????????????????????????????????????????????????????????????????????????????????????????????????????????lmerTest???????????????????????????
# 46)cipaird??????cipaird = T???????????????????????????????????????????????????????????????????????????
# 47)cipair??????cipair = T?????????????????????????????????????????????????????????
# 48)bgraph??????bgraph = "?????????????????????????????????"???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# ????????????bgraph = c("cind", "ciml")??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# ???????????????????????????????????????????????????????????????????????????????????????
# 
# ???????????????????????????????????????????????????????????????????????????????????????Holm??????????????????????????????????????????
# 
# > anovakun(x, "AsB", 2, 2, tech = T, holm = T)
# 
# ??????????????????
# 1)anovakun???????????????????????????????????????????????????26??????????????????????????????????????????????????????????????????????????????????????????????????????????????????26?????????LETTERS???letters???????????????????????????????????????
# 2)ci.calc????????????????????????????????????????????????????????????????????????????????????lmerTest???????????????????????????????????????????????????????????????lsmeans???????????????????????????Kenward-Roger??????
# 3)ss.calc?????????????????????????????????????????????????????????????????????????????????????????????????????????
# 4)epsilon.calc????????????????????????????????????????????????????????????????????????????????????Mendoza?????????????????????????????????????????????????????????????????????
# 5)epsilon.calc?????????????????????????????????????????????????????????????????????????????????????????????Mauchly????????????????????????????????????????????????????????????
# 6)epsilon.calc?????????????????????????????????????????????????????????????????????????????????????????????Harris?????????????????????????????????????????????????????????????????????
# 7)epsilon.calc???????????????Huynh-Feldt????????????????????????????????????Lecoutre???1991????????????????????????
# 8)epsilon.calc???????????????IGA???CIGA????????????????????????????????????????????????????????????Algina, 1997; Algina & Oshima, 1995???
# 9)anova.modeler????????????IGA???CIGA????????????????????????multiplier???b_hat???c_hat?????????????????????????????????F??????F????????????????????????
# 10)anova.modeler????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Dodd & Schultz, 1973????????????
# 11)mod.Bon????????????????????????????????????Shaffer?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 12mod.Bon??????????????????Shaffer????????????Holland-Copenhaver???????????????????????????????????????Rasmussen???1993??????Donoghue???2004??????????????????????????????????????????????????????????????????
# 13)mod.Bon????????????????????????????????????p???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# ????????????????????????????????????????????????????????????p?????????????????????????????????*????????????????????????????????????????????????????????????????????????????????????????????????
# ????????????????????????????????????????????????????????????*????????????????????????
# 14)pro.fraction??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 
# ???????????????????????????????????????
# hmean?????????????????????????????????
# read.clip???????????????????????????????????????????????????
# anovakun??????????????????????????????????????????
# uni.long????????????????????????????????????????????????????????????
# ci.calc??????????????????????????????????????????
# ci.bars????????????????????????????????????????????????
# elematch?????????????????????????????????????????????????????????????????????????????????
# expand.gmatrix?????????????????????????????????????????????
# sig.sign??????????????????????????????????????????????????????
# epsilon.calc??????Greenhouse-Geisser???Huynh-Feldt?????????????????????????????????
# ss.calc??????????????????????????????
# qlambda.ncf????????????F??????????????????????????????????????????????????????
# anova.modeler??????????????????????????????
# mpginv????????????????????????????????????????????????????????????
# wj.calc??????Welch-James????????????????????????????????????????????????
# mod.Bon????????????Bonferroni???????????????????????????????????????
# post.analyses???????????????????????????
# pro.fraction??????????????????????????????????????????????????????????????????
# boot.esci???????????????????????????????????????????????????????????????????????????????????????
# boot.anova?????????????????????????????????????????????????????????????????????????????????
# boot.inter???????????????????????????????????????????????????????????????
# anova.output??????????????????????????????????????????????????????
# table.out????????????????????????????????????????????????????????????
# mod.Bon.out????????????Bonferroni??????????????????????????????????????????????????????
# simeffects.out??????????????????????????????????????????????????????
# anovatan??????????????????????????????????????????????????????????????????????????????????????????
# 
# ???????????????????????????
# 1)anovakun version 1.0.0???R 2.5.1?????????2007/09/03?????????
# ?????????????????????????????????????????????????????????
# 2)anovakun version 2.0.0???R 2.5.1?????????2007/10/01?????????
# ?????????????????????????????????????????????epsilon.calc???????????????????????????????????????
# ???????????????????????????????????????ss.calc??????????????????elematch???????????????????????????????????????
# ??????????????????????????????????????????????????????????????????????????????MSe?????????????????????????????????????????????????????????mod.Bon????????????????????????????????????
# 3)anovakun version 2.1.0???R 2.5.1?????????2007/11/01?????????
# ??????????????????????????????????????????????????????????????????ss.calc???????????????????????????????????????
# 4)anovakun version 2.2.0???R 2.5.1???R 2.6.0?????????2007/12/03?????????
# ???QR??????????????????LAPACK?????????????????????????????????????????????????????????
# 5)anovakun version 3.0.0???R 2.5.1???R 2.6.0?????????2008/01/04?????????
# ??????????????????????????????????????????????????????????????????????????????????????????????????????ss.calc???????????????????????????????????????
# ???Shaffer?????????????????????????????????????????????????????????????????????????????????????????????mod.Bon??????????????????shaffer2???fshaffer1???fshaffer2????????????????????????
# ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????mod.Bon???????????????????????????????????????
# 6)anovakun version 3.1.0???R 2.5.1???R 2.6.0?????????2008/02/01?????????
# ???aov?????????????????????????????????????????????????????????????????????????????????????????????ss.calc????????????????????????????????????
# 7)anovakun version 3.2.0???R 2.5.1???R 2.6.0?????????2008/04/01?????????
# ???Shaffer????????????????????????????????????????????????????????????????????????mod.Bon??????????????????s2d???fs2d????????????????????????
# ????????????????????????????????????shaffer2???fshaffer1???fshaffer2?????????s2r???fs1???fs2r????????????
# ???????????????p_rep?????????????????????????????????anova.modeler?????????anovatab.out?????????????????????
# 8)anovakun version 4.0.0???R 2.5.1???R 2.6.0???R 2.7.0?????????2008/06/02?????????
# ???Mendoza??????????????????????????????Harris??????????????????????????????????????????????????????Mendoza?????????????????????????????????epsilon.calc????????????????????????????????????
# ???Huynh?????????????????????????????????Algina-Lecoutre???????????????????????????????????????????????????????????????epsilon.calc???????????????????????????????????????
# ????????????????????????????????????????????????anovakun?????????anova.modeler?????????epsilon.calc?????????pro.fraction?????????????????????
# ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????anova.modeler?????????pro.fraction?????????????????????
# 9)anovakun version 4.1.0???R 2.9.0???R 2.9.1???R 2.9.2?????????2009/09/01?????????
# ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 10)anovakun version 4.1.1???R 2.9.2???R 2.10.0???R 2.10.1?????????2010/01/04?????????
# ???R??????????????????????????????????????????
# ?????????????????????????????????????????????anovatab.out?????????simeffects.out???????????????
# 11)anovakun version 4.2.0???R 2.10.0???R 2.10.1???R 2.11.1?????????2010/07/01?????????
# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????anova.modeler?????????anovatab.out?????????????????????
# ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# ???Lecoutre???1991??????????????????Hyunh-Feldt??????????????????????????????????????????epsilon.calc???????????????
# 12)anovakun version 4.3.0???R 2.14.1???R 2.14.2???R 2.15.0?????????2012/07/02?????????
# ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????anova.modeler?????????pro.fraction?????????????????????
# ??????????????????????????????????????????????????????????????????????????????????????????anova.modeler?????????pro.fraction?????????????????????
# ?????????????????????????????????????????????????????????????????????????????????????????????????????????anova.modeler?????????pro.fraction?????????????????????
# ??????????????????????????????????????????????????????????????????copy????????????Linux??????????????????anovakun???????????????
# 13)anovakun version 4.3.1???R 2.15.0???R 2.15.1?????????2012/09/03?????????
# ???copy?????????Mac????????????????????????????????????anovakun??????????????? 
# 14)anovakun version 4.3.2???R 2.15.2?????????2013/01/04?????????
# ???read.clip???????????????
# ???nopost???????????????????????????anovakun?????????post.analysis???????????????
# ???copy?????????Linux???????????????????????????xclip?????????????????????????????????????????????????????????anovakun???????????????
# ??????????????????????????????????????????????????????????????????????????????bstat.out?????????anovatab.out?????????mod.Bon.out?????????simeffects.out?????????post.out?????????each.out???????????????
# 15)anovakun version 4.3.3???R 2.15.3???R 3.0.0?????????2013/05/07?????????
# ???R 3.0.0?????????????????????????????????ss.calc???????????????
# ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????pro.fraction???????????????
# ???????????????????????????anovatab.out?????????????????????
# 16)anovakun version 4.4.0???R 3.0.1???R 3.0.2?????????2013/11/01?????????
# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????anovakun???????????????
# ?????????????????????????????????????????????????????????????????????????????????anovakun?????????anova.modeler?????????post.analyses?????????pro.fraction?????????????????????
# ???????????????????????????bstat.out?????????anovatab.out?????????mod.Bon.out?????????simeffects.out?????????post.out?????????each.out???????????????
# ???????????????????????????????????????????????????????????????????????????????????????c?????????list???????????????????????????anova.modeler?????????pro.fraction???????????????
# 17)anovakun version 4.5.0???R 3.0.2?????????2014/02/03?????????
# ????????????????????????????????????????????????ci.calc??????????????????anovakun?????????bstat.out???????????????
# ???????????????????????????????????????uni.long????????????????????????uni.long??????????????????anovakun???????????????
# ???????????????????????????????????????????????????????????????????????????????????????anovatan???????????????
# 18)anovakun version 4.5.1???R 3.0.2?????????2014/03/03?????????
# ????????????????????????????????????????????????????????????????????????????????????????????????ci.calc???????????????
# ?????????????????????????????????????????????ci.calc???????????????
# 19)anovakun version 4.6.0???R 3.0.2???R 3.1.0?????????2014/06/02?????????
# ???????????????????????????????????????????????????????????????????????????????????????epsilon.calc???????????????
# ???Chi-Muller???????????????????????????????????????????????????????????????????????????epsilon.calc?????????anova.modeler?????????????????????
# ?????????????????????????????????????????????????????????????????????????????????????????????ss.calc?????????epsilon.calc?????????anova.modeler?????????????????????
# 20)anovakun version 4.6.1???R 3.1.0?????????2014/07/01?????????
# ???4.6.0??????????????????????????????IGA???CIGA???anovatan???????????????????????????????????????????????????anova.modeler?????????anovatan???????????????
# 21)anovakun version 4.6.2???R 3.1.0???R 3.1.1?????????2014/09/01?????????
# ????????????????????????????????????????????????????????????????????????????????????????????????lmerTest????????????ci.calc???????????????
# ?????????????????????????????????????????????????????????????????????ci.bars???????????????
# ??????????????????????????????????????????Welch???????????????????????????????????????????????????mpginv?????????wj.calc??????????????????mod.Bon?????????????????????
# 22)anovakun version 4.7.0???R 3.1.0???R 3.1.1???R 3.1.2?????????2015/01/05?????????
# ?????????F??????????????????????????????????????????????????????????????????????????????qlamdba.ncf??????????????????anova.modeler?????????????????????
# ??????????????????????????????????????????????????????????????????????????????????????????????????????boot.esci?????????boot.anova?????????boot.inter??????????????????????????????????????????
# ???????????????????????????anova.output?????????table.out??????????????????????????????????????????????????????
# 23)anovakun version 4.7.1???R 3.1.2???R 3.1.3?????????2015/04/01?????????
# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????episolon.calc???????????????
# ???type2???????????????????????????????????????????????????????????????ss.calc???????????????
# 24)anvoakun version 4.7.2???R 3.2.1???R 3.2.2?????????2015/10/01?????????
# ???????????????????????????????????????????????????????????????????????????pro.fraction???????????????
# 25)anovakun version 4.8.0???R 3.2.2???R 3.2.3?????????2016/02/01?????????
# ???Huynh?????????????????????????????????Algina-Lecoutre????????????????????????????????????????????????epsilon.calc?????????????????????
# 26)anovakun version 4.8.1???R 3.4.0???R 3.4.1?????????2017/08/01?????????
# ???long????????????????????????????????????????????????????????????????????????????????????uni.long???????????????
# 27)anovakun version 4.8.2???R 3.4.2?????????2018/0104?????????
# ???tech??????????????????????????????????????????????????????????????????????????????????????????????????????????????????anovakun???????????????
#
# ???????????????????????????????????????
# 1)anovakun??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 2)????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????anovakun?????????????????????????????????????????????
# 3)anovakun????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????


# ?????????????????????????????????
hmean <- function(datvector){
	return(length(datvector)/sum(1/datvector))
}


# ???????????????????????????????????????????????????
# read.table????????????????????????read.table???????????????????????????????????????????????????????????????
# OS?????????????????????????????????????????????????????????????????????????????????Linux???Ubuntu?????????????????????????????????xclip?????????????????????????????????????????????????????????
read.clip <- function(...){
	# OS???????????????????????????????????????????????????
	plat.info <- .Platform
	if(sum(grep("windows", plat.info)) != 0){# Windows?????????
		outboard <- "clipboard"
	}else if(sum(grep("mac", plat.info)) != 0){# Mac?????????
		outboard <- pipe("pbpaste")
	}else if(sum(grep("linux", R.version$system)) != 0){# Linux????????????xclip???????????????????????????????????????????????????
		system("xclip -o | xclip -sel primary")
		outboard <- "clipboard"
	}else{# ????????????OS??????????????????
		stop(message = "Unknown operating system!!")
	}

	# read.table???????????????
	read.table(file = outboard, ...)
}


# ANOVA??????????????????????????????????????????????????????
anovakun <- function(dataset, design, ..., long = FALSE, type2 = FALSE, nopost = FALSE, tech = FALSE, data.frame = FALSE, copy = FALSE, 
	holm = FALSE, hc = FALSE, s2r = FALSE, s2d = FALSE, fs1 = FALSE, fs2r = FALSE, fs2d = FALSE, welch = FALSE, criteria = FALSE, 
	lb = FALSE, gg = FALSE, hf = FALSE, cm = FALSE, auto = FALSE, mau = FALSE, har = FALSE, iga = FALSE, ciga = FALSE, 
	eta = FALSE, peta = FALSE, geta = NA, eps = FALSE, peps = FALSE, geps = NA, omega = FALSE, omegana = FALSE, pomega = FALSE, 
	gomega = NA, gomegana = NA, prep = FALSE, nesci = FALSE, besci = FALSE, cilmd = FALSE, cilm = FALSE, cind = FALSE, cin = FALSE, 
	ciml = FALSE, cipaird = FALSE, cipair = FALSE, bgraph = c(NA, NA)){
	maxfact <- nchar(design) - 1# ???????????????????????????????????????

	# ??????????????????????????????
	datform <- uni.long(dataset = dataset, design = design, ... = ..., long = long)
	dat <- datform$dat
	factnames <- datform$factnames
	flev <- datform$flev
	miscase <- datform$miscase

	# ??????????????????????????????
	if(sum(is.na(bgraph)) < 2){# ??????????????????????????????????????????????????????????????????????????????
		eval(parse(text = paste0(bgraph, " <- TRUE")))
	}
	baseresults <- ci.calc(dat = dat, design = design, factnames = factnames, 
		cilmd = cilmd, cilm = cilm, cind = cind, cin = cin, ciml = ciml, cipaird = cipaird, cipair = cipair)

	# anova.modeler??????????????????????????????????????????????????????????????????
	mainresults <- anova.modeler(dat = dat, design = design, factnames = factnames, type2 = type2, lb = lb, gg = gg, hf = hf, 
		cm = cm, auto = auto, mau = mau, har = har, iga = iga, ciga = ciga, eta = eta, peta = peta, geta = geta, 
		eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, pomega = pomega, gomega = gomega, 
		gomegana = gomegana, prep = prep, nesci = nesci)

	# post.analyses??????????????????????????????????????????????????????????????????????????????????????????
	postresults <- post.analyses(dat = dat, design = design, factnames = factnames, mainresults = mainresults, type2 = type2, 
		nopost = nopost, holm = holm, hc = hc, s2r = s2r, s2d = s2d, fs1 = fs1, fs2r = fs2r, fs2d = fs2d, welch = welch, 
		criteria = criteria, lb = lb, gg = gg, hf = hf, cm = cm, auto = auto, mau = mau, har = har, iga = iga, ciga = ciga, 
		eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, pomega = pomega, 
		gomega = gomega, gomegana = gomegana, prep = prep, nesci = nesci)

	# ??????????????????????????????????????????????????????????????????????????????????????????
	if(besci){
		bootes <- boot.esci(dat, design, factnames = factnames, type2 = type2, nopost = nopost, mainresults = mainresults, 
			postresults = postresults, lb = lb, gg = gg, hf = hf, cm = cm, auto = auto, mau = mau, har = har, iga = iga, ciga = ciga, 
			eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, 
			pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep, B = 2000, conf.level = 0.95)
		mainresults$besci.info <- bootes$besci.info
		mainresults$bescitab <- bootes$bescitab[[1]]
		if(length(bootes$bescitab) > 1){# ?????????????????????????????????????????????
			postnames <- names(postresults)
			intnames <- postnames[nchar(postnames) == 3]# ?????????????????????????????????????????????????????????
			for(i in 1:length(intnames)){
				postresults[[intnames[i]]]$bescitab <- bootes$bescitab[[i + 1]]
			}
		}
	}

	# ?????????????????????
	info1 <- paste0("[ ", design, "-Type Design ]")# ??????????????????
	info2 <- paste0("This output was generated by anovakun 4.8.2 under ", strsplit(R.version$version.string, " \\(")[[1]][1], ".")# ???????????????????????????
	info3 <- paste0("It was executed on ", date(), ".")# ????????????
	exe.info <- c(info1, info2, info3)

	# Unbalanced??????????????????????????????????????????????????????????????????????????????
	if(length(unique(baseresults$bstatist$n)) != 1){
		if(type2 == TRUE) mainresults$ano.info1 <- append(mainresults$ano.info1, c("== This data is UNBALANCED!! ==", "== Type II SS is applied. =="))
		else mainresults$ano.info1 <- append(mainresults$ano.info1, c("== This data is UNBALANCED!! ==", "== Type III SS is applied. =="))
	}

	# ??????????????????????????????
	if(miscase != 0){
		baseresults$bstat.info1 <- append(baseresults$bstat.info1, paste0("== The number of removed case is ", miscase, ". =="))
	}

	# ?????????????????????
	if(copy){# ?????????????????????????????????????????????????????????????????????
		plat.info <- .Platform
		if(sum(grep("windows", plat.info)) != 0){# Windows?????????
			sink("clipboard", split = TRUE)
		}else if(sum(grep("mac", plat.info)) != 0){# Mac?????????
			tclip <- pipe("pbcopy", "w")
			sink(tclip, split = TRUE)
		}else if(sum(grep("linux", R.version$system)) != 0){# Linx????????????xclip???????????????????????????????????????????????????
			tclip <- pipe("xclip -selection clipboard")
			sink(tclip, split = TRUE)
		}
	}
	if(tech){# ????????????????????????????????????????????????
		postnames <- names(postresults)
		intnames <- postnames[nchar(postnames) == 3]# ?????????????????????????????????????????????????????????
		if(length(intnames) > 0){
			for(i in intnames){
				postresults[[i]] <- postresults[[i]][-(7:9)]# sim.dmat???sim.cellN???sim.flev????????????
			}
		}
		if(is.null(mainresults$besci.info)){
			retlist <-list("INFORMATION" = rbind(info1, info2, info3), 
				"DESCRIPTIVE STATISTICS" = baseresults, 
				"SPHERICITY INDICES" = list(mainresults$epsi.info1, mainresults$epsitab), 
				"ANOVA TABLE" = list(mainresults$ano.info1, mainresults$anovatab, mainresults$nescitab), 
				"POST ANALYSES" = postresults)
		}else{
			retlist <-list("INFORMATION" = rbind(info1, info2, info3), 
				"DESCRIPTIVE STATISTICS" = baseresults, 
				"SPHERICITY INDICES" = list(mainresults$epsi.info1, mainresults$epsitab), 
				"ANOVA TABLE" = list(mainresults$ano.info1, mainresults$anovatab, mainresults$nescitab), 
				"EFFECT SIZE INFORMATION" = list(mainresults$besci.info, mainresults$bescitab), 
				"POST ANALYSES" = postresults)
		}
		if(data.frame == TRUE){
			names(dat) <- c("s", factnames, "y")
			retlist <- c(retlist, list("DATA.FRAME" = dat))# ???????????????????????????????????????????????????
		}
		return(retlist)
	}else{# ??????????????????????????????
		if(data.frame == TRUE){
			names(dat) <- c("s", factnames, "y")
			anova.output(maxfact = maxfact, exe.info = exe.info, baseresults = baseresults, 
				mainresults = mainresults, postresults = postresults)
			return(list("DATA.FRAME" = dat))# ???????????????????????????????????????????????????
		}else{
			anova.output(maxfact = maxfact, exe.info = exe.info, baseresults = baseresults, 
				mainresults = mainresults, postresults = postresults)
		}
	}
	if(copy){
		sink()
		if(plat.info$OS.type != "windows"){# Mac???Linux?????????
			close(tclip)
		}
	}

	# ??????????????????????????????????????????????????????
	if(sum(is.na(bgraph)) < 2 & maxfact <= 3){
		ci.bars(dat, design, factnames = factnames, inn.tier = bgraph[1], out.tier = bgraph[2])
	}
}


# ????????????????????????????????????????????????????????????
uni.long <- function(dataset, design, ..., long = FALSE){
	maxfact <- nchar(design) - 1# ???????????????????????????????????????
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????
	levlist <- list(...)

	# ??????????????????????????????
	if(long){# ??????????????????????????????????????????????????????ANOVA?????????????????????????????????
		# ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		if((maxfact + 2) != ncol(dataset)){
			stop(message = "\"anovakun\" has stopped working...\nThe entered design does not match the data.")
		}

		# ????????????????????????
		misv <- suppressWarnings(as.numeric(sapply(dataset[, ncol(dataset)], function(x) as.vector(x))))# ?????????????????????NA???????????????
		dat <- cbind(data.frame(lapply(dataset[, 1:(maxfact+1), drop = FALSE], function(x) factor(x, levels = unique(x)))), misv)# ????????????factor????????????
		if(setequal(names(dataset), paste0("V", 1:ncol(dataset))) == TRUE | is.null(names(dataset)) == TRUE){# ??????????????????????????????????????????
			factnames <- LETTERS[1:maxfact]# ????????????????????????????????????????????????????????????
			levlist <- lapply(1:maxfact, function(x) paste0(letters[x], 1:length(unique(dataset[, x+1]))))
			for(i in 1:maxfact){# ????????????????????????????????????????????????????????????????????????
				levels(dat[, i+1]) <- levlist[[i]]# ?????????????????????
			}
		}else{# ???????????????????????????????????????
			factnames <- names(dataset)[-c(1, maxfact+2)]# ??????????????????????????????????????????????????????????????????
		}

		dat <- dat[do.call(order, dat[(ncol(dat)-1):1]), ]
		names(dat) <- c("s", LETTERS[1:maxfact], "y")
		flev <- sapply(dat, nlevels)[-c(1, maxfact+2)]# ?????????????????????
		attributes(flev) <- NULL# attributes?????????

		# ??????????????????
		if(!anyNA(misv)){# ???????????????????????????
			miscase <- 0# ?????????????????????
		}else{# ????????????????????????
			misid <- dataset[is.na(misv), 1]# ??????????????????ID
			dat <- dat[rowSums(sapply(misid, function(x) x == dat[, 1])) == 0, ]# dat??????NA?????????ID??????????????????????????????
			miscase <- length(misid)# ?????????????????????
		}
	}else{# ??????????????????????????????????????????????????????????????????
		# ????????????????????????????????????????????????
		if(is.null(names(levlist))){# ??????????????????????????????????????????
			flev <- unlist(levlist)# ?????????????????????
			factnames <- LETTERS[1:maxfact]# ?????????????????????
			levlist <- lapply(1:length(flev), function(x) paste0(letters[x], 1:flev[x]))
		}else{# ???????????????????????????????????????
			flev <- sapply(levlist, length)# ?????????????????????
			attributes(flev) <- NULL# attributes?????????
			factnames <- names(levlist)# ?????????????????????
		}

		# ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		if(min(flev) == 1){
			stop(message = "\"anovakun\" has stopped working...\nSome factor specifies only one level.\nOr maybe non-existent option-names are requested.")
		}

		# ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		if((betlen + ifelse(is.na(prod(flev[(betlen+1):length(flev)])), 1, prod(flev[(betlen+1):length(flev)]))) != ncol(dataset)){
			stop(message = "\"anovakun\" has stopped working...\nThe entered design does not match the data.")
		}

		# ??????????????????
		misv <- suppressWarnings(as.numeric(sapply(dataset[, (betlen+1):ncol(dataset)], function(x) as.vector(x))))# ?????????????????????NA???????????????
		cdata <- array(misv, c(nrow(dataset), ncol(dataset) - betlen))# NA???????????????
		compcase <- complete.cases(cdata)# ???????????????
		dataset <- dataset[compcase, ]# dataset??????NA????????????????????????????????????
		miscase <- sum(!compcase)# ?????????????????????
		depv <- as.vector(cdata[compcase, ])# ??????????????????????????????
		slab <- rep(paste0("s", 1:nrow(dataset)), ncol(dataset) - betlen)# ?????????????????????
		dat <- data.frame(factor(slab, levels = unique(slab)))# ??????????????????????????????????????????????????????

		# ?????????????????????????????????
		if(betlen > 0){
			betlab <- data.frame(lapply(dataset[, 1:betlen, drop = FALSE], function(x) factor(x, levels = unique(x))))# ?????????????????????????????????factor?????????????????????????????????????????????????????????
			for(i in 1:betlen){# ????????????????????????????????????????????????????????????????????????
				levels(betlab[, i]) <- levlist[[i]]# ?????????????????????
			}
			betlab <- do.call("rbind", replicate(ncol(dataset) - betlen, betlab, simplify = FALSE))# ??????????????????????????????????????????
			dat <- cbind(dat, betlab)# ??????????????????????????????
		}
		# ?????????????????????????????????
		if(withlen > 0){
			eachcue <- c(sapply(1:withlen, function(x) prod(flev[(betlen+x):maxfact])), 1)[-1]
			timescue <- prod(flev[(betlen+1):maxfact]) / (eachcue * flev[(betlen+1):maxfact])
			withlab <- data.frame(lapply(1:withlen, function(x) factor(rep(levlist[[betlen+x]], each = nrow(dataset) * eachcue[x], 
				times = timescue[x]), levels = levlist[[betlen+x]])))# ???????????????????????????????????????????????????????????????
			dat <- cbind(dat, withlab)# ??????????????????????????????
		}
		dat <- cbind(dat, depv)# ?????????????????????????????????????????????
		names(dat) <- c("s", LETTERS[1:maxfact], "y")
	}
	return(list("dat" = dat, "factnames" = factnames, "flev" = flev, "miscase" = miscase))
}


# ??????????????????????????????????????????
ci.calc <- function(dat, design, factnames = NA, conf.level = 0.95, cilmd = FALSE, cilm = FALSE, cind = FALSE, cin = FALSE, ciml = FALSE, cipaird = FALSE, cipair = FALSE){
	maxfact <- nchar(design) - 1
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????
	cellN <- length(unique(dat$s))# ??????????????????????????????????????????????????????
	flev <- sapply(2:(maxfact+1), function(x) nlevels(dat[, x]))# ?????????????????????
	comlev <- prod(flev[(betlen+1):maxfact])# ?????????????????????????????????????????????????????????
	bstat.info1 <- NULL
	bstat.info2 <- NULL

	# factnames???????????????????????????????????????????????????
	if(anyNA(factnames)) factnames <- LETTERS[1:maxfact]

	# ??????????????????????????????????????????????????????
	tabbase <- tapply(dat$y, dat[, (maxfact+1):2], function(x) x)
	sncol <- sapply(tabbase, function(x) length(x))# ????????????????????????????????????
	mncol <- sapply(tabbase, function(x) mean(x, na.rm = TRUE))# ??????????????????????????????
	sdcol <- sapply(tabbase, function(x) sd(x, na.rm = TRUE))# ????????????????????????????????????

	# ?????????????????????????????????????????????????????????????????????????????????????????????????????????
	maincols <- expand.grid(lapply((maxfact+1):2, function(x) levels(dat[, x])))
	maincols <- maincols[, order(maxfact:1)]# ?????????????????????????????????????????????

	# ??????????????????????????????????????????????????????
	bstatist <- data.frame(maincols, sncol, mncol, sdcol)
	names(bstatist) <- c(factnames, "n", "Mean", "S.D.")# ??????????????????????????????????????????

	# Loftus-Masson????????????????????????
	if(cilmd || cilm){
		# ?????????????????????????????????????????????
		pSS <- sum(dat$y^2) - sum(tapply(dat$y, interaction(dat[, 2:(maxfact+1)]), function(x) sum(x)^2/length(x)))
		pDF <- nrow(dat) - prod(flev)

		# ????????????????????????????????????????????????????????????????????????
		if(betlen == 0){
			pSS <- pSS - (comlev * sum(tapply(dat$y, list(dat$s), function(x) mean(x)^2)) - sum(dat$y)^2/nrow(dat))
			pDF <- pDF - (cellN - 1)
		}

		ci.tval <- qt((1 - conf.level)/2, pDF, lower.tail = FALSE) * sqrt(pSS / pDF * mean(1/sncol))

		# ???????????????????????????????????????
		if(cilmd){
			bstat.info1 <- append(bstat.info1, "== Loftus-Masson's Difference-Adjusted Pooled Confidence Intervals ==")
			bstatist <- cbind(bstatist, "CILMD-L" = mncol - ci.tval / sqrt(2), "CILMD-U" = mncol + ci.tval / sqrt(2))
		}
		if(cilm){
			bstat.info1 <- append(bstat.info1, "== Loftus-Masson's Pooled Confidence Intervals ==")
			bstatist <- cbind(bstatist, "CILM-L" = mncol - ci.tval, "CILM-U" = mncol + ci.tval)
		}
	}

	# ??????????????????????????????????????????
	if(cind || cin){
		# ????????????????????????????????????
		if(withlen == 0){# ???????????????????????????
			nd.info <- "== Difference-Adjusted Confidence Intervals for Independent Means =="
			n.info <- "== Confidence Intervals for Independent Means =="
			vcom <- as.vector(tapply(dat$y, dat[, (betlen+1):2], function(x) sd(x)/sqrt(length(x))))
			ci.tval <- qt((1 - conf.level)/2, sncol - 1, lower.tail = FALSE) * vcom
		}else{# ?????????????????????????????????
			nd.info <- "== Cousineau-Morey-Baguley's Difference-Adjusted Normalized Confidence Intervals =="
			n.info <- "== Cousineau-Morey's Normalized Confidence Intervals =="
			if(betlen == 0){# ??????????????????????????????????????????????????????????????????
				caldat <- list(dat)
			}else{# ?????????????????????????????????????????????????????????????????????????????????
				caldat <- split(dat, dat[, (maxfact+1-withlen):2])
			}

			wdat <- lapply(caldat, function(x) data.frame(matrix(x$y[order(eval(parse(text = paste0("x[, ", c(1, (maxfact+1):(betlen+2)), "]"))))], length(x$y)/comlev, comlev)))# ???????????????????????????????????????????????????????????????tapply???????????????????????????????????????????????????????????????
			normdat <- lapply(wdat, function(x) x - matrix(rowMeans(x, na.rm = TRUE), nrow(x), 1) + mean(colMeans(x, na.rm = TRUE), na.rm = TRUE))# ????????????????????????????????????????????????????????????
			nsd <- unlist(lapply(normdat, function(x) sapply(x, function(y) sd(y, na.rm = TRUE))), use.names = FALSE)# ?????????????????????????????????????????????????????????
			ci.tval <- qt((1 - conf.level)/2, sncol - 1, lower.tail = FALSE) * sqrt(comlev / (comlev - 1)) * nsd/sqrt(sncol)
		}

		# ???????????????????????????????????????
		if(cind){
			bstat.info1 <- append(bstat.info1, nd.info)
			bstatist <- cbind(bstatist, "CIND-L" = mncol - ci.tval / sqrt(2), "CIND-U" = mncol + ci.tval / sqrt(2))
		}
		if(cin){
			bstat.info1 <- append(bstat.info1, n.info)
			bstatist <- cbind(bstatist, "CIN-L" = mncol - ci.tval, "CIN-U" = mncol + ci.tval)
		}
	}

	# ????????????????????????????????????????????????????????????
	if(ciml){
		loadstate <- search()# ????????????????????????????????????????????????????????????
		pkchk <- library(lmerTest, logical.return = TRUE)# ??????????????????????????????
		if(pkchk == FALSE) stop("Please install lmerTest package to use ciml option!!")# ??????????????????????????????????????????
		def.contr <- suppressWarnings(lmerControl()$checkControl)# lmerControl?????????????????????????????????
		options(lmerControl = list(check.nobs.vs.nlev = "ignore", check.nlev.gtr.1 = "ignore", check.nobs.vs.nRE = "ignore"))# ????????????????????????????????????

		# ?????????????????????
		modeleq <- paste0("y ~ ", gsub(", ", " * ", toString(LETTERS[maxfact:1])))# ?????????????????????
		if(withlen > 0){# ??????????????????????????????????????????
			if(withlen == 1){
				randeq <- " + (1 | s)"
			}else{
				randeq <- paste0(" + (1 | s)", paste0(" + (1 | ", LETTERS[(betlen+1):maxfact], ":s)", collapse = ""))
			}
			modeleq <- paste0(modeleq, randeq)
		}

		# ??????????????????????????????
		ml.model <- lmer(formula(modeleq), na.action = na.omit, REML = TRUE, data = dat)
		lscis <- lsmeans(ml.model, test.effs = paste0(LETTERS[maxfact:1], collapse = ":"), ddf = "Kenward-Roger")

		options(lmerControl = def.contr)# lmerControl?????????????????????
		newstate <- search()# ????????????????????????????????????????????????
		detlist <- newstate[!is.element(newstate, loadstate)]# ???????????????????????????????????????????????????
		detdummy <- sapply(detlist, function(x) detach(x, character.only = TRUE))# ????????????????????????

		# ???????????????????????????????????????
		bstat.info1 <- append(bstat.info1, "== Blouin-Riopelle's Multilevel-Based Confidence Intervals ==")
		bstatist <- cbind(bstatist, "CIML-L" = lscis$lsmeans.table$"Lower CI", "CIML-U" = lscis$lsmeans.table$"Upper CI")
	}

	# ????????????????????????????????????????????????????????????????????????????????????
	if(ncol(bstatist) != (maxfact + 3)) bstat.info1 <- append(bstat.info1, paste0("== ", 100 * conf.level, "% confidence intervals are calculated. =="))
	ciset <- list("bstat.info1" = bstat.info1, "bstatist" = bstatist)

	# ????????????????????????????????????
	if(cipaird || cipair){
		if(withlen == 0){# ??????????????????????????????????????????????????????????????????
			bstat.info2 <- "*** CAUTION! Pairwise confidence intervals are not suitable for between-subject designs. ***"
			ciset <- append(ciset, list("bstat.info2" = bstat.info2))
		}else{# ?????????????????????????????????
			if(betlen == 0){# ??????????????????????????????????????????????????????????????????
				caldat <- list(dat)
				betlabels <- data.frame(row.names = 1:(comlev * (comlev - 1) / 2))
			}else{# ?????????????????????????????????????????????????????????????????????????????????
				caldat <- split(dat, dat[, (maxfact+1-withlen):2])
				betlabels <- expand.grid(lapply((maxfact+1-withlen):2, function(x) levels(dat[, x])))
				betlabels <- betlabels[, order(betlen:1), drop = FALSE]# ?????????????????????????????????????????????
				betlabels <- betlabels[rep(1:nrow(betlabels), each = comlev * (comlev - 1) / 2), , drop = FALSE]
				row.names(betlabels) <- NULL
				names(betlabels) <- factnames[1:betlen]
			}

			wdat <- lapply(caldat, function(x) data.frame(matrix(x$y[order(eval(parse(text = paste0("x[, ", c(1, (maxfact+1):(betlen+2)), "]"))))], length(x$y)/comlev, comlev)))# ???????????????????????????????????????????????????????????????tapply???????????????????????????????????????????????????????????????
			ddat <- lapply(wdat, function(x) combn(comlev, 2, function(y) x[, y[1]] - x[, y[2]]))# ???????????????????????????
			pairbase <- lapply(ddat, function(x) data.frame("Diff" = colMeans(x), "n" = nrow(x), "S.E." = apply(x, 2, function(y) sd(y)/sqrt(length(y)))))# ?????????????????????????????????????????????????????????????????????
			pairtab <- do.call(rbind, pairbase)
			rownames(pairtab) <- NULL

			crosslevels <- expand.grid(lapply((maxfact+1):(betlen+2), function(x) levels(dat[, x])), stringsAsFactors = FALSE)
			comblabels <- apply(crosslevels, 1, function(x) gsub(", ", ".", toString(x[withlen:1])))
			withlabels <- rep(combn(comlev, 2, function(x) gsub(", ", "-", toString(comblabels[x]))), times = prod(flev[pmin(1:betlen, betlen)]))

			pairtab <- cbind(betlabels, "Pairs" = withlabels, pairtab)
			ci.tval <- qt((1 - conf.level)/2, pairtab$"n" - 1, lower.tail = FALSE) * pairtab$"S.E."

			# ???????????????????????????????????????
			if(cipaird){
				bstat.info2 <- append(bstat.info2, "== Franz-Loftus's Difference-Adjusted Pairwise Confidence Intervals ==")
				pairtab <- cbind(pairtab, "CIPRD-L" = pairtab$Diff - ci.tval / sqrt(2), "CIPRD-U" = pairtab$Diff + ci.tval / sqrt(2))
			}
			if(cipair){
				bstat.info2 <- append(bstat.info2, "== Franz-Loftus's Pairwise Confidence Intervals ==")
				pairtab <- cbind(pairtab, "CIPR-L" = pairtab$Diff - ci.tval, "CIPR-U" = pairtab$Diff + ci.tval)
			}
			bstat.info2 <- append(bstat.info2, paste0("== ", 100 * conf.level, "% confidence intervals are calculated. =="))
			ciset <- append(ciset, list("bstat.info2" = bstat.info2, "pairtab" = pairtab))
		}
	}
	return(ciset)
}


# ????????????????????????????????????????????????
# ?????????????????????????????????
# barmin?????????????????????????????????
ci.bars <- function(dat, design, factnames = NA, conf.level = 0.95, inn.tier = "cind", out.tier = NA, main = NULL, ylab = NULL, barmin = 0){
	maxfact <- nchar(design) - 1
	flev <- sapply(2:(maxfact + 1), function(x) nlevels(dat[, x]))# ?????????????????????

	# factnames???????????????????????????????????????????????????
	if(anyNA(factnames)) factnames <- LETTERS[1:maxfact]

	# ?????????????????????
	eval(parse(text = paste0(c("cilmd", "cilm", "cind", "cin", "ciml"), "v <- FALSE")))
	eval(parse(text = paste0(inn.tier, "v <- TRUE")))
	eval(parse(text = paste0(out.tier, "v <- TRUE")))
	baseresults <- ci.calc(dat, design, factnames = factnames, conf.level = conf.level, cilmd = cilmdv, cilm = cilmv, cind = cindv, cin = cinv, ciml = cimlv)
	bstatist <- baseresults$bstatist

	# ???????????????????????????????????????
	if(sum(grep("mac", .Platform)) != 0){# Mac?????????
		quartz(title = paste0("Bar Graph for ", design, "-Type Design"))
	}else{# ????????????OS?????????
		x11(title = paste0("Bar Graph for ", design, "-Type Design"))
	}

	# ?????????????????????????????????
	preset <- par(no.readonly = TRUE)
	par(lwd = 1.5, cex = 1.8, plt = c(0.2, 0.7, 0.2, 0.87), mgp = c(2.5, 0.5, 0), xpd = TRUE)
	if(is.na(out.tier) == TRUE){# ????????????????????????????????????
		mMax <- max(bstatist[, paste0(toupper(inn.tier), "-U")])# ?????????
		mMin <- min(bstatist[, paste0(toupper(inn.tier), "-L")])# ?????????
	}else{# ????????????????????????????????????
		mMax <- max(bstatist[, paste0(toupper(out.tier), "-U")])# ?????????
		mMin <- min(bstatist[, paste0(toupper(out.tier), "-L")])# ?????????
	}
	mcoef <- 10^(nchar(abs(round(mMax)))-2)
	betbars <- rep(c(1, rep(0, flev[maxfact] - 1)), prod(flev)/flev[maxfact])# ???????????????
	if(length(flev) == 3){
		gdivs <- (1:prod(flev))[(1:prod(flev) %% (prod(flev)/flev[1])) == 0]
		gdivs <- gdivs[-length(gdivs)]
		betbars[gdivs + 1] <- 2
	}
	barcolor <- gray(0.5/flev[maxfact] * flev[maxfact]:1 + 0.45)

	# ??????????????????
	barplot(matrix(bstatist$Mean, prod(flev)/flev[maxfact], flev[maxfact]), 
		las = 2, space = betbars, tcl = 0.25, ylab = ylab, 
		ylim = c(pmin(barmin, floor(mMin/mcoef) * mcoef), ceiling(mMax/mcoef) * mcoef), 
		xlim = c(0.5, length(betbars) + (prod(flev)/flev[maxfact])^(1 * (sum(betbars) != 1)) + 1 * sum(betbars == 2)), 
		col = barcolor, 
		xpd = FALSE, beside = TRUE)
	box(bty = "l")# ?????????????????????
	title(main, line = 0.8)# ?????????????????????

	# ??????????????????
	if(maxfact == 1){# ?????????????????????????????????????????????????????????????????????
		xlabpos <- flev/2 + 1
		text(xlabpos, 0, pos = 1, offset = 1, labels = factnames)
	}else{
		for(i in pmax(maxfact - 1, 1):1){# ?????????????????????????????????
			xlabframe <- unique(bstatist[, 1:i, drop = FALSE])
			xtf <- betbars >= (maxfact - i)
			xtf[1] <- TRUE
			xcue <- (1:length(betbars))[xtf] + mean(1:(prod(flev)/prod(flev[1:i]))) - 1
			xlabpos <- cumsum(c(0.5, betbars[-1]))[xcue] + xcue# ????????????????????????
			text(xlabpos, pmin(barmin, floor(mMin/mcoef) * mcoef), pos = 1, offset = 1.2 * pmax(maxfact - i, 1) - 0.4, labels = xlabframe[, i])
		}
	}

	# ??????
	legend(length(betbars) + sum(betbars) + 0.5, ceiling(mMax/mcoef) * mcoef, 
		legend = levels(bstatist[, maxfact]), cex = 0.9, x.intersp = 0.6, y.intersp = 1, 
		pch = 22, pt.bg = barcolor, pt.cex = 1.6, # ???????????????????????????????????????
		bty = "n")

	# ???????????????
	if(is.na(out.tier) == FALSE){# ???????????????????????????????????????????????????
		arrows(cumsum(betbars) + 1:prod(flev) - 0.5, bstatist[, paste0(toupper(out.tier), "-L")], # ?????????????????????
			cumsum(betbars) + 1:prod(flev) - 0.5, bstatist[, paste0(toupper(out.tier), "-U")], 
			angle = 90, length = 0.04, code = 3, lwd = 2)
	}
	arrows(cumsum(betbars) + 1:prod(flev) - 0.5, bstatist[, paste0(toupper(inn.tier), "-L")], # ?????????????????????
		cumsum(betbars) + 1:prod(flev) - 0.5, bstatist[, paste0(toupper(inn.tier), "-U")], 
		angle = 90, length = 0.06, code = 3, lwd = 2)
	par(preset)# ????????????????????????????????????????????????
}


# ?????????????????????????????????????????????????????????????????????????????????
# grep??????????????????A:C???????????????????????????????????????????????????????????????A:B:C????????????????????????????????????????????????????????????????????????????????????
# ??????????????????????????????????????????grep????????????????????????
elematch <- function(Mstrings, stex){
	# ????????????????????????????????????????????????????????????grep???????????????
	matchlist <- lapply(strsplit(Mstrings, "")[[1]], function(x) grep(x, stex))

	# ???????????????????????????????????????????????????????????????????????????
	buffer <- matchlist[[1]]

	# ?????????????????????????????????grep??????????????????????????????
	if(length(matchlist) != 1){
		for(i in 2:length(matchlist)){
			buffer <- buffer[is.element(buffer, matchlist[[i]])]
		}
	}
	return(buffer)
}


# ?????????????????????????????????????????????
# expand.grid????????????????????????????????????????????????matrix????????????
expand.gmatrix <- function(...){
	elem <- list(...)
	if(is.list(elem[[1]])) elem <- unlist(elem, recursive = FALSE)
	elemsize <- sapply(elem, length)
	rcue <- c(1, cumprod(elemsize)[-length(elemsize)])
	rlev <- cumprod(elemsize)
	levmax <- prod(elemsize)
	expmat <- mapply(function(w, x, y, z) rep.int(rep.int(w, rep.int(y, x)), prod(elemsize)/z), elem, elemsize, rcue, rlev)
	return(expmat)
}


# ??????????????????????????????????????????????????????
sig.sign <- function(pvalue){
	ifelse(is.na(pvalue), "", 
	ifelse(pvalue < 0.001, "***", 
	ifelse(pvalue < 0.01, "**", 
	ifelse(pvalue < 0.05, "*", 
	ifelse(pvalue < 0.10, "+", "ns")))))
}


# Greenhouse-Geisser???Huynh-Feldt???????????????????????????????????????
# ?????????????????????????????????????????????????????????????????????????????????????????????
epsilon.calc <- function(dat, design, mau = FALSE, har = FALSE, iga = FALSE, ciga = FALSE, lb = FALSE, gg = FALSE, hf = FALSE, 
	cm = FALSE, autov = NULL, flev = NULL, cellN = NULL, esboot = FALSE){
	maxfact <- nchar(design) - 1# ???????????????????????????????????????
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????
	if(is.null(flev)) flev <- sapply(2:(maxfact+1), function(x) nlevels(dat[, x]))# ?????????????????????
	if(is.null(cellN)) cellN <- length(unique(dat$s))# ???????????????????????????????????????????????????????????????

	# ???????????????????????????
	replabel <- (maxfact - withlen + 2):(maxfact + 1)
	repnum <- sort(replabel, decreasing = TRUE)# ????????????????????????????????????????????????
	repmat <- flev[repnum - 1]# ???????????????????????????????????????
	rl <- prod(repmat)# ?????????????????????????????????????????????????????????

	# ????????????????????????????????????????????????????????????
	if(betlen == 0){# ???????????????????????????????????????????????????????????????????????????
		othlabel <- 1
		ol <- 1
		othN <- cellN# ????????????????????????????????????cellN?????????????????????
		covmatrices <- list(cov(do.call(cbind, split(dat$y, dat[, repnum]))))
	}else{# ?????????????????????????????????????????????????????????????????????????????????
		# ???????????????????????????
		othlabel <- 1:betlen + 1
		othnum <- sort(othlabel, decreasing = TRUE)# ????????????????????????????????????????????????
		othmat <- flev[othnum - 1]# ???????????????????????????????????????
		ol <- prod(othmat)# ????????????????????????????????????????????????
		sdat <- split(dat$y, dat[, othnum])
		othN <- sapply(sdat, length) / rl# ?????????????????????????????????????????????????????????????????????????????????
		covmatrices <- lapply(sdat, function(x) cov(matrix(x, ncol = rl)))
	}

	# ????????????????????????????????????
	tm <- Reduce(f = "+", x = lapply(1:ol, function(w) (othN[w] - 1) * covmatrices[[w]])) / (cellN - ol)

	# ?????????????????????????????????????????????????????????????????????????????????????????????????????????
	combmat <- expand.gmatrix(lapply(repmat - 1, function(x) 0:x))
	cuemat <- cbind(1:nrow(combmat), colSums(t(combmat != 0) * 10^((withlen-1):0)), rowSums(combmat != 0))
	ortho.ord <- unlist(lapply(0:withlen, function(x) cuemat[cuemat[, 3] == x, 1][sort.list(cuemat[cuemat[, 3] == x, 2])]))
	ortho.helm <- Reduce(f = kronecker, x = lapply(flev[replabel - 1], function(w) cbind(1, contr.helmert(w))))
	ortho.helm <- ortho.helm[, ortho.ord]# ????????????????????????????????????
	ortho.coef <- t(ortho.helm[, 2:rl, drop = FALSE])# ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????drop = FALSE?????????
	ortho.denomi <- rowSums(ortho.coef^2)^(1/2)

	# ??????????????????????????????????????????
	orthoM <- ortho.coef / ortho.denomi

	# ?????????????????????????????????????????????????????????
	if(withlen == 1){# ????????????????????????????????????
		matdivider <- flev[replabel - 1] - 1# ?????????????????????????????????????????????
		effect.name <- paste0(names(dat)[replabel], collapse = ":")# ???????????????????????????
		ss.name <- paste0(paste0(c("s", LETTERS[othlabel - 1]), collapse = ":"), ":", effect.name)

		# ???????????????????????????????????????
		seportM <- list(orthoM)
		totalM <- seportM
		gmd <- matdivider
		otoM <- orthoM %*% tm %*% t(orthoM)# ??????????????????????????????????????????????????????
		ss.er <- (cellN - ol) * sum(diag(otoM))
		df.er <- (cellN - ol) * nrow(otoM)
		otoM <- list(otoM)
	}else{# ???????????????????????????????????????
		ctlframe <- unlist(lapply(1:withlen, function(y) combn(replabel, y, function(x) x, simplify = FALSE)), recursive = FALSE)
		matdivider <- unlist(lapply(ctlframe, function(x) prod(flev[x - 1] - 1)))# ?????????????????????????????????????????????
		effect.name <- unlist(lapply(ctlframe, function(x) paste0(names(dat)[x], collapse = ":")))# ???????????????????????????
		ss.name <- paste0(paste0(c("s", LETTERS[othlabel - 1]), collapse = ":"), ":", effect.name)

		# ??????????????????
		effect.name <- c("Global", effect.name)

		# ???????????????????????????????????????????????????????????????????????????
		divpoint <- mapply(function(x, y) seq(x, y), cumsum(matdivider) - (matdivider - 1), cumsum(matdivider), SIMPLIFY = FALSE)
		seportM <- lapply(divpoint, function(x) orthoM[x, , drop = FALSE])
		totalM <- c(list(orthoM), seportM)
		gmd <- c(rl - 1, matdivider)
		otoM <- lapply(totalM, function(x) x %*% tm %*% t(x))# ??????????????????????????????????????????????????????
		ss.er <- sapply(otoM, function(x) (cellN - ol) * sum(diag(x)))[-1]
		df.er <- sapply(otoM, function(x) (cellN - ol) * nrow(x))[-1]
	}
	ss.errs <- matrix(c(ss.er, df.er), ncol = 2, dimnames = list(ss.name, c("ss.col", "df.col")))

	# ??????????????????????????????
	LB.ep <- 1 / gmd
	GG.ep <- sapply(otoM, function(x) sum(diag(x))^2 / (nrow(x) * sum(x^2)))
	HF.ep <- ((cellN - ol + 1) * gmd * GG.ep - 2) / (gmd * (cellN - ol - gmd * GG.ep))# Lecoutre???1991????????????
	va <- (cellN - ol - 1) + (cellN - ol) * (cellN - ol - 1) / 2
	CM.ep <- pmax(LB.ep, HF.ep * (va - 2) * (va - 4) / va^2)

	# ????????????????????????
	if(esboot){# ??????????????????????????????????????????????????????
		if(lb){
			sph.ep <- LB.ep[min(withlen, 2):length(gmd)]
		}else if(gg){
			sph.ep <- GG.ep[min(withlen, 2):length(gmd)]
		}else if(hf){
			sph.ep <- HF.ep[min(withlen, 2):length(gmd)]
		}else if(cm){
			sph.ep <- CM.ep[min(withlen, 2):length(gmd)]
		}else if(!is.null(autov)){
			sph.ep <- GG.ep[min(withlen, 2):length(gmd)]
			sph.ep[autov] <- 1
		}else{
			sph.ep <- rep(1, nrow(ss.errs))
		}
		return(list("ss.errs" = ss.errs, "sph.ep" = sph.ep))
	}else{
		if(mau){# Mauchly??????????????????
			# ????????????????????????
			epsi.info1 <- paste0("== Mauchly's Sphericity Test and Epsilons ==")
			lamlab <- "W"
			eps.Lambda <- sapply(otoM, function(x) det(x) / (sum(diag(x)) / nrow(x))^nrow(x))
			eps.m <- 1 - (2 * gmd^2 + gmd + 2) / (6 * (cellN - ol) * gmd)
			epsChi <- -(cellN - ol) * eps.m * log(eps.Lambda)

			if(any(min(othN) < gmd)){# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
				epsChi[min(othN) < gmd] <- NA
				eps.Lambda[min(othN) < gmd] <- NA
				epsi.info1 <- paste0(epsi.info1, "\n", 
					"*** CAUTION! The test of SPHERICITY is INVALID because of small sample size. ***", "\n", 
					"*** The minimum sample size for valid computation is N = ", max(gmd) + 1, " at each group. ***")
			}

			eps.df <- gmd * (gmd + 1)/ 2 - 1
			eps.p1 <- pchisq(epsChi, ifelse(eps.df == 0, NA, eps.df), lower.tail = FALSE)
			eps.p2 <- pchisq(epsChi, eps.df + 4, lower.tail = FALSE)
			eps.w2 <- (gmd + 2) * (gmd - 1) * (gmd - 2) * (2 * gmd^3 + 6 * gmd^2 + 3 * gmd + 2) / (288 * gmd^2 * (cellN - ol)^2 * eps.m^2)
			eps.p <- eps.p1 + eps.w2 * (eps.p2 - eps.p1)
		}else if(har){# Harris???????????????????????????
			# ????????????????????????
			epsi.info1 <- paste0("== Harris's Multisample Sphericity Test and Epsilons ==")
			lamlab <- "h_hat"
			proA <- lapply(totalM, function(x) lapply(covmatrices, function(y) x %*% y %*% t(x)))
			epsTr <- lapply(proA, function(y) sapply(y, function(x) sum(diag(x))))
			epsSq <- lapply(proA, function(y) sapply(y, function(x) sum(diag(x %*% x))))
			eps.Lambda <- sapply(1:length(proA), function(x) sum((othN - 1) * epsTr[[x]])^2 / sum((othN - 1) * epsSq[[x]]))
			epsChi <- pmax(0, ((cellN - ol) * gmd / 2) * ((cellN - ol) * gmd / eps.Lambda - 1))# ??????????????????????????????

			if(any(min(othN) < gmd)){# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
				epsChi[min(othN) < gmd] <- NA
				eps.Lambda[min(othN) < gmd] <- NA
				epsi.info1 <- paste0(epsi.info1, "\n", 
					"*** CAUTION! The test of SPHERICITY is INVALID because of small sample size. ***", "\n", 
					"*** The minimum sample size for valid computation is N = ", max(gmd) + 1, " at each group. ***")
			}

			eps.df <- ((ol * gmd * (gmd + 1)) / 2) - 1
			eps.p0 <- pchisq(epsChi, ifelse(eps.df == 0, NA, eps.df), lower.tail = FALSE)
			eps.p6 <- pchisq(epsChi, eps.df + 6, lower.tail = FALSE)
			eps.p4 <- pchisq(epsChi, eps.df + 4, lower.tail = FALSE)
			eps.p2 <- pchisq(epsChi, eps.df + 2, lower.tail = FALSE)
			eps.p <- pmax(0, eps.p0 + ((gmd^3 + 3 * gmd^2 - 8 * gmd - 12 - 200/gmd) * eps.p6 / 12 
				+ (-2 * gmd^3 - 5 * gmd^2 + 7 * gmd + 12 + 420/gmd) * eps.p4 / 8 
				+ (gmd^3 + 2 * gmd^2 - gmd - 2 - 216/gmd) * eps.p2 / 4 
				+ (-2 * gmd^3 - 3 * gmd^2 + gmd + 436/gmd) * eps.p0 / 24 
				) / (cellN - ol))
		}else{# Mendoza???????????????????????????
			# ????????????????????????
			epsi.info1 <- paste0("== Mendoza's Multisample Sphericity Test and Epsilons ==")
			lamlab <- "Lambda"
			proA <- lapply(totalM, function(x) lapply(1:ol, function(y) x %*% (othN[y] * covmatrices[[y]]) %*% t(x)))
			eps.m <- 1 - ((((cellN-ol) * gmd^2 * (gmd + 1) * (2 * gmd + 1) - (2*(cellN-ol) * gmd^2)) * 
				sum(1/(othN-1)) - 4) / (6 * (cellN-ol) * gmd * (ol * gmd * (gmd + 1) - 2)))
			eps.m[is.nan(eps.m)] <- 0# NaN????????????????????????????????????

			menL1 <- log(cellN-ol) * ((cellN-ol)*(gmd)/2) - sapply(gmd, function(x) sum(log(othN-1) * ((othN-1) * x / 2)))
			menL2 <- sapply(proA, function(y) sum(sapply(y, function(x) determinant(x, logarithm = TRUE)$modulus[1]) * (othN-1)/2))
			menL3 <- sapply(proA, function(y) sum(diag(Reduce(f = "+", x = y)/nrow(y[[1]]))))
			menL3 <- log(ifelse(menL3 < 0, NA, menL3)) * ((cellN-ol) * gmd / 2)# ???????????????????????????????????????????????????????????????NA???????????????
			menL <- menL1 + menL2 - menL3
			epsChi <- - 2 * eps.m * menL
			eps.Lambda <- exp(menL)

			if(any(min(othN) < gmd)){# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
				epsChi[min(othN) < gmd] <- NA
				eps.Lambda[min(othN) < gmd] <- NA
				epsi.info1 <- paste0(epsi.info1, "\n", 
					"*** CAUTION! The test of SPHERICITY is INVALID because of small sample size. ***", "\n", 
					"*** The minimum sample size for valid computation is N = ", max(gmd) + 1, " at each group. ***")
			}

			eps.df <- ol * gmd * (gmd + 1) / 2 - 1
			eps.p1 <- pchisq(epsChi, ifelse(eps.df == 0, NA, eps.df), lower.tail = FALSE)
			eps.p2 <- pchisq(epsChi, eps.df + 4, lower.tail = FALSE)
			eps.w2 <- (gmd + 2) * (gmd - 1) * (gmd - 2) * (2 * gmd^3 + 6 * gmd^2 + 3 * gmd + 2) / (288 * gmd^2 * (cellN - ol)^2 * eps.m^2)
			eps.p <- eps.p1 + eps.w2 * (eps.p2 - eps.p1)
		}

		# ?????????????????????????????????????????????
		sig.mark <- sig.sign(eps.p)
		epsitab <- data.frame("Effect" = effect.name, "Dummy" = eps.Lambda, "approx.Chi" = epsChi, "df" = eps.df, 
			"p" = eps.p, "sig.mark" = sig.mark, "LB" = LB.ep, "GG" = GG.ep, "HF" = HF.ep, "CM" = CM.ep)
		names(epsitab)[2] <- lamlab# ???????????????????????????????????????????????????
	}

	# ??????????????????IGA??????????????????????????????
	if(iga || ciga){
		# Huynh???Improved General Approximate Test
		wt.name <- effect.name[effect.name != "Global"]
		wtlen <- length(wt.name)
		proSj <- lapply(seportM, function(y) lapply(covmatrices, function(x) y %*% x %*% t(y)))
		trDj <- lapply(proSj, function(y) sapply(y, function(x) sum(diag(x))))
		trDj2 <- lapply(proSj, function(y) sapply(y, function(x) sum(diag(x %*% x))))

		ldat <- cbind(1, dat[, -1])
		sdat <- split(dat, ldat[, cummin((betlen+1):2)])
		lxn <- lapply(sdat, function(x) matrix(x$y[order(eval(parse(text = paste0("x[, ", c(1, (maxfact+1):(betlen+2)), "]"))))], length(x$y)/rl, rl))
		ssize <- sapply(sdat, function(x) nrow(x)/rl)# ????????????????????????????????????
		sscp <- lapply(lxn, function(x) t(x) %*% (diag(nrow(x)) - 1/nrow(x)) %*% x)
		vcv <- lapply(1:ol, function(x) sscp[[x]]/(ssize[x]-1))
		vcdng <- lapply(1:ol, function(x) vcv[[x]]/ssize[x])
		zeromat <- list(matrix(0, rl, rl))
		iga.Sigstr <- do.call(rbind, lapply(1:ol, function(x) do.call(cbind, ifelse(1:ol == x, vcdng[x], zeromat))))

		if(ol == 1){# ?????????????????????????????????
			invXX <- diag(1)/ssize
			cmat <- list(matrix(1))# ????????????????????????????????????????????????????????????????????????????????????
			iga.eta <- mapply(function(y, z) sum((othN - 1)^3 / ((othN + 1) * (othN - 2)) * (othN * y^2 - 2 * z)), trDj, trDj2)
			bw.df <- 1

			iga.filler <- NULL
			iga.letfill <- NULL
			iga.label <- effect.name
		}else{# ????????????????????????????????????????????????
			invXX <- diag(1/ssize)
			factcomb <- expand.gmatrix(replicate(betlen, list(0:1)))[-1, , drop = FALSE]# ?????????????????????????????????
			comblabel <- apply(factcomb, 1, function(x) paste0(LETTERS[1:betlen][x == 1], collapse = ":"))# ?????????????????????
			names(comblabel) <- NULL
			labord <- order(nchar(comblabel), comblabel)
			factcomb <- factcomb[labord, , drop = FALSE]# ????????????????????????????????????????????????????????????????????????
			comblabel <- comblabel[labord]# ????????????????????????????????????
			row.names(factcomb) <- comblabel# ???????????????????????????????????????????????????
			rmat <- lapply(flev, function(x) cbind(1, -1 * diag(x - 1)))# ????????????????????????????????????????????????????????????
			rvec <- lapply(flev, function(x) array(1, c(1, x)))# ?????????????????????????????????????????????????????????????????????
			doubler <- list(rvec, rmat)
			cmat <- lapply(1:nrow(factcomb), function(w) Reduce(f = kronecker, x = lapply(1:betlen, function(y) 
				doubler[[c(factcomb[w, y] + 1, y)]])))# ???????????????????????????????????????
			cmat <- c(list(array(rep(1, ol), c(1, ol))), cmat)# ????????????????????????????????????????????????????????????????????????????????????
			iga.eta <- mapply(function(y, z) sum((othN - 1)^3 / ((othN + 1) * (othN - 2)) * (othN * y^2 - 2 * z)) + 
				2 * sum(combn(ol, 2, function(x) prod((othN[x] - 1) * y[x]))), trDj, trDj2)
			bw.df <- sapply(cmat, nrow)

			iga.filler <- rep(NA, wtlen * (length(bw.df) - 1))
			iga.letfill <- rep("", wtlen * (length(bw.df) - 1))
			iga.label <- c(setdiff(effect.name, wt.name), unlist(lapply(wt.name, function(x) c(x, paste(comblabel, x, sep = ":")))))
		}

		iga.G <- unlist(lapply(seportM, function(w) lapply(cmat, function(x) t(x) %*% 
			qr.coef(qr(x %*% invXX %*% t(x), LAPACK = TRUE), diag(nrow(x))) %*% x %x% (t(w) %*% w))), recursive = FALSE)
		rs <- sapply(seportM, function(w) sum((ssize-1) * sapply(vcv, function(x) sum(diag(w %*% x %*% t(w))))))
		iga.GS <- lapply(iga.G, function(x) x %*% iga.Sigstr)
		iga.h0 <- sapply(iga.GS, function(x) sum(diag(x))^2) / sapply(iga.GS, function(x) sum(diag(x %*% x)))
		iga.m <- sapply(iga.GS, function(x) ((cellN - ol) * sum(diag(x)))) / as.vector(tcrossprod(bw.df, rs))
		iga.h <- ifelse(iga.h0 == 1, 1, (bw.df * (cellN * iga.h0 - 2 * bw.df)) / ((cellN - ol) * bw.df - iga.h0))
		iga.sigma <- mapply(function(x, y) sum((othN - 1)^2 / ((othN + 1) * (othN - 2)) * ((othN - 1) * y - x^2)), trDj, trDj2)
		iga.e <- iga.eta / iga.sigma

		# Algina-Lecoutre???Corrected Improved General Approximation Test??????????????????
		bw.dfr <- rep(bw.df, each = length(seportM))
		iga.al <- ifelse(iga.h0 == 1, 1, (bw.dfr * ((cellN - ol + 1) * iga.h0 - 2 * bw.df)) / ((cellN - ol) * bw.dfr - iga.h0))

		# ?????????????????????????????????????????????
		bwlen <- length(bw.df)
		iga.e <- rep(iga.e, each = bwlen)
		if(withlen == 1){# ????????????????????????????????????
			iga.ord <- order(c(seq(from = 1, by = bwlen, length.out = wtlen) - 0:(wtlen-1), 
				seq(from = 1, length.out = wtlen * (bwlen - 1))))
		}else{# ??????????????????????????????????????????
			iga.m <- c(NA, iga.m)
			iga.h <- c(NA, iga.h)
			iga.al <- c(NA, iga.al)
			iga.e <- c(NA, iga.e)
			iga.ord <- c(0, order(c(seq(from = 1, by = bwlen, length.out = wtlen) - 0:(wtlen-1), 
				seq(from = 1, length.out = wtlen * (bwlen - 1))))) + 1
		}
		if(iga){# IGA
			epsi.info1 <- sub("Epsilons", "Estimates for IGA", epsi.info1)
			epsitab <- data.frame("Effect" = iga.label, "Dummy" = c(eps.Lambda, iga.filler)[iga.ord], 
				"approx.Chi" = c(epsChi, iga.filler)[iga.ord], "df" = c(eps.df, iga.filler)[iga.ord], 
				"p" = c(eps.p, iga.filler)[iga.ord], "sig.mark" = c(sig.mark, iga.letfill)[iga.ord], 
				"multiplier" = iga.m, "adj.ndf" = iga.h, "adj.ddf" = iga.e)
		}else{# CIGA
			epsi.info1 <- sub("Epsilons", "Estimates for CIGA", epsi.info1)
			epsitab <- data.frame("Effect" = iga.label, "Dummy" = c(eps.Lambda, iga.filler)[iga.ord], 
				"approx.Chi" = c(epsChi, iga.filler)[iga.ord], "df" = c(eps.df, iga.filler)[iga.ord], 
				"p" = c(eps.p, iga.filler)[iga.ord], "sig.mark" = c(sig.mark, iga.letfill)[iga.ord], 
				"multiplier" = iga.m, "adj.ndf" = iga.al, "adj.ddf" = iga.e)
		}
		names(epsitab)[2] <- lamlab# ???????????????????????????????????????????????????
	}

	return(list("epsi.info1" = epsi.info1, "epsitab" = epsitab, "ss.errs" = ss.errs))
}


# ??????????????????????????????
ss.calc <- function(dat, design, ss.errs = NA, type2 = FALSE, dmat = NULL, flev = NULL, cellN = NULL){
	maxfact <- nchar(design) - 1# ???????????????????????????????????????
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????
	if(is.null(flev)) flev <- sapply(2:(maxfact+1), function(x) nlevels(dat[, x]))# ?????????????????????
	if(is.null(cellN)) cellN <- length(unique(dat$s))
	ol <- prod(flev[min(1, betlen):betlen])# ??????????????????????????????????????????????????????????????????????????????????????????????????????

	eff.elem <- unlist(lapply(1:maxfact, function(y) combn(maxfact, y, function(x) paste0(LETTERS[x], collapse = ":"))))
	eff.modeleq <- paste0("~ ", paste(eff.elem, collapse = " + "))

	def.contr <- options("contrasts")[[1]]# contrasts?????????????????????????????????
	options(contrasts = c("contr.sum", "contr.poly"))# ???????????????
	if(is.null(dmat)) dmat <- model.matrix(as.formula(eff.modeleq), dat)# ???????????????????????????

	# ???????????????????????????????????????
	exmat <- cbind(dmat, dat$y)# ?????????????????????
	promat <- crossprod(exmat)# ???????????????????????????
	endline <- nrow(promat)# ?????????????????????

	# ??????????????????????????????????????????????????????????????????
	sepcol <- attr(dmat, "assign")# ??????????????????????????????????????????????????????????????????
	pivot.col <- lapply(1:max(sepcol), function(x) (1:length(sepcol))[sepcol == x])# ????????????????????????????????????
	df.col <- sapply(pivot.col, function(x) length(x))

	if(type2){# ???????????????????????????????????????????????????????????????
		# ??????????????????????????????
		# ?????????????????????????????????????????????
		names(pivot.col) <- eff.elem
		ss.line1 <- lapply(eff.elem, function(x) c(1, unlist(pivot.col[match(x, names(pivot.col))]), unlist(pivot.col[-elematch(x, names(pivot.col))])))
		ss.line2 <- lapply(eff.elem, function(x) c(1, unlist(pivot.col[-elematch(x, names(pivot.col))])))

		# ?????????????????????????????????????????????????????????????????????????????????????????????
		ss.base1 <- sapply(ss.line1, function(x) colSums(qr.coef(qr(promat[x, x], LAPACK = TRUE), promat[x, endline]) * promat[x, endline, drop = FALSE]))
		ss.base2 <- sapply(ss.line2, function(x) colSums(qr.coef(qr(promat[x, x], LAPACK = TRUE), promat[x, endline]) * promat[x, endline, drop = FALSE]))

		# ?????????????????????????????????????????????????????????????????????
		ss.all <- ss.base1 - ss.base2
	}else{# ???????????????????????????????????????????????????????????????
		# ??????????????????????????????
		eff.line <- c(1, unlist(pivot.col))

		# ?????????????????????????????????????????????
		ss.line <- lapply(pivot.col, function(x) eff.line[-x])

		# ???????????????????????????????????????????????????????????????????????????????????????
		ss.eff <- sum(qr.coef(qr(promat[eff.line, eff.line], LAPACK = TRUE), promat[eff.line, endline]) * promat[eff.line, endline, drop = FALSE])
		ss.base <- sapply(ss.line, function(x) sum(qr.coef(qr(promat[x, x], LAPACK = TRUE), promat[x, endline]) * promat[x, endline, drop = FALSE]))

		# ?????????????????????????????????????????????????????????????????????
		ss.all <- ss.eff - ss.base
	}

	# ????????????????????????
	ss.T <- promat[endline, endline] - qr.coef(qr(promat[1, 1], LAPACK = TRUE), promat[1, endline]) * promat[1, endline]

	# ????????????????????????
	ss.Er <- promat[endline, endline] - sum(qr.coef(qr(promat[1:(endline-1), 1:(endline-1)], LAPACK = TRUE), promat[1:(endline-1), endline]) * promat[1:(endline-1), endline])

	ss.results <- matrix(c(ss.all, ss.Er, ss.T, df.col, cellN - ol, nrow(dat) - 1), ncol = 2, 
		dimnames = list(c(eff.elem, "Error", "Total"), c("ss.col", "df.col")))

	if(!anyNA(ss.errs)){# ?????????????????????????????????
		ss.res <- ss.Er - sum(ss.errs[, 1], na.rm = TRUE)
		res.name <- paste0(strsplit(paste0("s", strsplit(design, "s")[[1]][1]), "")[[1]], collapse = ":")
		res.er <- cbind(ss.res, cellN - ol)
		row.names(res.er) <- res.name

		bst <- sum(choose(betlen, 1:betlen)) * (betlen != 0)# ???????????????????????????????????????
		wst <- sum(choose(withlen, 1:withlen))# ???????????????????????????????????????
		er.pos <- cumsum(c(bst+1, rep(bst+2, wst)))# ?????????????????????

		if(betlen == 0){# ???????????????????????????
			ss.pos <- 1:wst
		}else{# ???????????????????????????
			ss.fig <- rbind(1:(nrow(ss.results) - 2), do.call(rbind, lapply(LETTERS[1:maxfact], function(x) 1 * grepl(x, eff.elem))))
			withsize <- 2^(0:(withlen-1))
			withbox <- do.call(cbind, lapply(withsize, function(x) rep.int(rep.int(0:1, rep.int(x, 2)), max(withsize)/x)))[-1, , drop = FALSE]
			withbox <- withbox[order(rowSums(withbox)), , drop = FALSE]
			ss.pos <- c(ss.fig[1, colSums(ss.fig[(maxfact-withlen+1):maxfact + 1, , drop = FALSE]) == 0], unlist(lapply(1:nrow(withbox), function(x) ss.fig[1, colSums(ss.fig[(maxfact-withlen+1):maxfact + 1, , drop = FALSE] == withbox[x, ]) == withlen])))
		}

		ss.results <- rbind(ss.results[-(nrow(ss.results)-1), ], res.er, ss.errs)# ????????????????????????
		ss.order <- order(c((1:(nrow(ss.results)-2))[-er.pos][order(ss.pos)], nrow(ss.results), er.pos))# ??????????????????????????????
		ss.results <- ss.results[ss.order, ]
	}

	options(contrasts = def.contr)# contrasts?????????????????????
	return(list("ss.results" = ss.results, "dmat" = dmat))
}


# ??????F????????????????????????????????????????????????????????????
# conf.limits.ncf???MBESS????????????????????????????????????????????????????????????????????????????????????
# Kelley, K. (2007). Confidence intervals for standardized effect sizes: Theory, application, and implementation. Journal of Statistical Software, 20, 8.
qlambda.ncf <- function (Fratio, ndf, ddf, conf.level = 0.95, tol = 1e-09, JmpProp = 0.1){
	lwalp <- (1 - conf.level)/2
	upalp <- (1 - conf.level)/2
	Fratio[Fratio == Inf] <- 0

	# ???????????????
	Llim <- c()# ????????????????????????????????????????????????
	Lbase <- qf(p = lwalp * 5e-04, df1 = ndf, df2 = ddf)
	delta <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Lbase) - (1 - lwalp)
	if(any(delta < 0)){# ???????????????????????????????????????
		Lbase[pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = 0) < (1 - lwalp)] <- 1e-08
		if(any(pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Lbase) < (1 - lwalp))){
			Lbase[pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Lbase) < (1 - lwalp)] <- NA
			Llim[delta < 0] <- NA
		}
	}

	if(!all(is.na(Lbase))){# ????????????????????????????????????
		Lvec <- c()
		L1 <- Lbase
		L2 <- Lbase
		repeat{
			L2 <- L1 * (1 + JmpProp)
			delta <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = L2) - (1 - lwalp)
			if(any(delta <= tol, na.rm = TRUE)){
				tpos <- grep(TRUE, delta <= tol)
				Lvec[tpos] <- L2[tpos]
				L2[tpos] <- NA
				delta[tpos] <- NA
				if(all(is.na(delta))) break
			}
			L1 <- L2
		}
		Lguidel <- Lvec / (1 + JmpProp)
		Lguider <- Lvec
		Lmid <- (Lguidel + Lguider)/2

		delta <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Lmid) - (1 - lwalp)
		repeat{
			if(any(abs(delta) <= tol, na.rm = TRUE)){
				dpos <- grep(TRUE, delta <= tol)
				Llim[dpos] <- Lmid[dpos]
				Lmid[dpos] <- NA
				delta[dpos] <- NA
				if(all(is.na(delta))) break
			}
			delta.mid <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Lmid) - (1 - lwalp) > tol
			delta.gl <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Lguidel) - (1 - lwalp) > tol
			delta.gr <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Lguider) - (1 - lwalp) <= tol
			gvec <- delta.gl & delta.gr
			if(any(gvec, na.rm = TRUE)){
				tpos <- grep(TRUE, gvec & delta.mid)
				fpos <- grep(TRUE, gvec & !delta.mid)
				Lguidel[tpos] <- Lmid[tpos]
				Lguider[tpos] <- Lguider[tpos]
				Lguidel[fpos] <- Lguidel[fpos]
				Lguider[fpos] <- Lmid[fpos]
				Lmid <- (Lguidel + Lguider)/2
			}
			delta <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Lmid) - (1 - lwalp)
		}
	}

	# ???????????????
	Ulim <- c()# ????????????????????????????????????????????????
	Ubase <- qf(p = 1 - upalp * 5e-04, df1 = ndf, df2 = ddf)
	delta <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Ubase) - upalp
	if(any(delta < 0)){# ???????????????????????????????????????
		Ubase[pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Ubase) < upalp] <- 1e-08
		if(any(pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Ubase) < upalp)){
			Ubase[pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Ubase) < upalp] <- NA
			Ulim[delta < 0] <- NA
		}
	}

	if(!all(is.na(Ubase))){# ????????????????????????????????????
		Uvec <- c()
		U1 <- Ubase
		U2 <- Ubase
		repeat{
			U2 <- U1 * (1 + JmpProp)
			delta <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = U2) - upalp
			if(any(delta <= tol, na.rm = TRUE)){
				tpos <- grep(TRUE, delta <= tol)
				Uvec[tpos] <- U2[tpos]
				U2[tpos] <- NA
				delta[tpos] <- NA
				if(all(is.na(delta))) break
			}
			U1 <- U2
		}
		Uguidel <- Uvec / (1 + JmpProp)
		Uguider <- Uvec
		Umid <- (Uguidel + Uguider)/2

		delta <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Umid) - upalp
		repeat{
			if(any(abs(delta) <= tol, na.rm = TRUE)){
				dpos <- grep(TRUE, delta <= tol)
				Ulim[dpos] <- Umid[dpos]
				Umid[dpos] <- NA
				delta[dpos] <- NA
				if(all(is.na(delta))) break
			}
			delta.mid <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Umid) - upalp > tol
			delta.gl <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Uguidel) - upalp > tol
			delta.gr <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Uguider) - upalp <= tol
			gvec <- delta.gl & delta.gr
			if(any(gvec, na.rm = TRUE)){
				tpos <- grep(TRUE, gvec & delta.mid)
				fpos <- grep(TRUE, gvec & !delta.mid)
				Uguidel[tpos] <- Umid[tpos]
				Uguider[tpos] <- Uguider[tpos]
				Uguidel[fpos] <- Uguidel[fpos]
				Uguider[fpos] <- Umid[fpos]
				Umid <- (Uguidel + Uguider)/2
			}
			delta <- pf(q = Fratio, df1 = ndf, df2 = ddf, ncp = Umid) - upalp
		}
	}
	return(list("lower.limit" = Llim, "upper.limit" = Ulim))
}


# ??????????????????????????????
anova.modeler <- function(dat, design, factnames = NA, type2 = FALSE, dmat = NULL, flev = NULL, cellN = NULL, full.elem = NA, 
	epsi.effect = NA, lb = FALSE, gg = FALSE, hf = FALSE, cm = FALSE, auto = FALSE, autov = NULL, mau = FALSE, har = FALSE, 
	iga = FALSE, ciga = FALSE, eta = FALSE, peta = FALSE, geta = NA, eps = FALSE, peps = FALSE, geps = NA, omega = FALSE, 
	omegana = FALSE, pomega = FALSE, gomega = NA, gomegana = NA, prep = FALSE, nesci = FALSE, inter = NA, bet.mse = NULL, 
	gss.qT = NA, post.esdenomis = NA, post.df.adj = NA, post.mse.adj = NA, esboot = FALSE, es.conf.level = 0.95){
	maxfact <- nchar(design) - 1# ???????????????????????????????????????
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????
	if(is.null(flev)) flev <- sapply(2:nchar(design), function(x) length(unique(dat[, x])))# ?????????????????????
	if(is.null(cellN)) cellN <- length(unique(dat$s))

	# factnames????????????????????????????????????????????????????????????????????????
	if(anyNA(factnames)) factnames <- LETTERS[1:maxfact]

	# ???????????????????????????????????????????????????
	if(anyNA(full.elem)){
		factmat <- cbind(c("s", LETTERS[1:maxfact]), c("s", factnames))
		full.elem <- do.call(cbind, lapply(1:(maxfact+1), function(y) combn(1:(maxfact+1), y, function(x) c(paste0(factmat[x, 1], collapse = ":"), paste0(factmat[x, 2], collapse = " x ")))))
		full.elem <- cbind(full.elem, "Error", "Total")
	}
	if(anyNA(epsi.effect)) epsi.effect <- c("Global", unlist(lapply((betlen+1):maxfact, function(y) combn(factnames[(betlen+1):maxfact], y - betlen, function(x) paste0(x, collapse = " x ")))))

	# ????????????????????????????????????
	if(withlen == 0){# ???????????????????????????
		# epsilon.calc??????????????????????????????
		epsi.info1 <- NA
		epsitab <- NULL
		ss.errs <- NA
		ano.info1 <- NULL
	}else{# ?????????????????????????????????
		# epsilon.calc?????????
		epsiresults <- epsilon.calc(dat = dat, design = design, flev = flev, cellN = cellN, mau = mau, har = har, 
			iga = iga, ciga = ciga, lb =lb, gg = gg, hf = hf, cm = cm, autov = autov, esboot = esboot)
		epsi.info1 <- epsiresults$epsi.info1
		epsitab <- epsiresults$epsitab
		ss.errs <- epsiresults$ss.errs
	}

	# ss.calc?????????
	sres <- ss.calc(dat = dat, design = design, dmat = dmat, ss.errs = ss.errs, type2 = type2, flev = flev, cellN = cellN)
	ss.results <- sres$ss.results
	ss.col <- ss.results[, 1]# ????????????????????????
	df.col <- ss.results[, 2]# ????????????????????????
	internal.lab <- row.names(ss.results)
	source.col <- full.elem[2, match(internal.lab, full.elem[1, ])]
	eflen <- length(ss.col)

	# ???????????????????????????????????????
	if(withlen == 0){# ???????????????????????????
		mse.row <- length(source.col) - 1
	}else{# ??????????????????????????????????????????
		mse.row <- grep("s", internal.lab)

		# ???????????????????????????????????????????????????????????????????????????
		if(esboot){# ???????????????????????????????????????
			mdf <- pmin(1, rep(c(1, epsiresults$sph.ep), c(mse.row[1], diff(mse.row))))
		}else if(iga){
			mdf <- 1
			ano.info1 <- "== Huynh's Improved General Approximation Test =="
		}else if(ciga){
			mdf <- 1
			ano.info1 <- "== Algina-Lecoutre's Corrected Improved General Approximation Test =="
		}else if(lb){
			mdf <- pmin(1, rep(c(1, epsitab$LB[epsitab$Effect != "Global"]), c(mse.row[1], diff(mse.row))))
			ano.info1 <- "== Geisser-Greenhouse's Conservative Test =="
		}else if(gg){
			mdf <- pmin(1, rep(c(1, epsitab$GG[epsitab$Effect != "Global"]), c(mse.row[1], diff(mse.row))))
			ano.info1 <- "== Adjusted by Greenhouse-Geisser's Epsilon =="
		}else if(hf){
			mdf <- pmin(1, rep(c(1, epsitab$HF[epsitab$Effect != "Global"]), c(mse.row[1], diff(mse.row))))
			ano.info1 <- "== Adjusted by Huynh-Feldt-Lecoutre's Epsilon =="
		}else if(cm){
			mdf <- pmin(1, rep(c(1, epsitab$CM[epsitab$Effect != "Global"]), c(mse.row[1], diff(mse.row))))
			ano.info1 <- "== Adjusted by Chi-Muller's Epsilon =="
		}else if(auto){
			sigepsi <- epsitab
			sigepsi$GG[((sigepsi$sig.mark == "") | (sigepsi$sig.mark == "ns"))] <- 1
			mdf <- pmin(1, rep(c(1, sigepsi$GG[sigepsi$Effect != "Global"]), c(mse.row[1], diff(mse.row))))
			ano.info1 <- "== Adjusted by Greenhouse-Geisser's Epsilon for Suggested Violation =="
		}else{
			mdf <- 1
			ano.info1 <- NULL
		}

		# ????????????????????????
		df.col <- c(mdf, 1) * df.col
	}

	dbase <- rep(1, eflen)
	dbase[c(mse.row, length(dbase))] <- NA
	f.denomi <- rep(mse.row, c(mse.row[1], diff(mse.row)))
	f.denomi[mse.row] <- NA
	f.denomi <- c(f.denomi, NA)

	# ????????????????????????
	if(!is.null(bet.mse)){# MSe?????????????????????
		ss.col[mse.row] <- bet.mse[[2]]# ss.col
		df.col[mse.row] <- bet.mse[[3]]# df.col
		ss.qT <- gss.qT
	}else{
		ss.qT <- sum(ss.col[-eflen])
	}
	ms.col <- ss.col / df.col# MS???????????????
	f.col <- ms.col[1:length(ms.col)] / ms.col[f.denomi]# F??????????????????

	# IGA???CIGA?????????
	if((iga && !is.na(epsi.info1[1])) | (ciga && !is.na(epsi.info1[1]))){
		fillnames <- c("", paste0(source.col, " x ")[seq(from = 1, length.out = mse.row[1] - 1)])
		epsi.effect <- c("Global", unlist(lapply(epsi.effect[-1], function(x) paste0(fillnames, x))))
		wenum <- length(mse.row) - 1
		mfv <- c(rep(1, mse.row[1]), epsitab$multiplier[epsitab$Effect != "Global"], rep(NA, wenum))
		mfv <- c(mfv[order(c(1:(length(mfv) - wenum), mse.row[-1] - (1:wenum)))], 1)

		iga.df <- c(df.col[1:mse.row[1]], epsitab$adj.ndf[epsitab$Effect != "Global"], 
			epsitab$adj.ddf[epsitab$Effect != "Global"][seq(from = 1, by = mse.row[1], length.out = wenum)])
		iga.df <- iga.df[order(c(1:(length(iga.df) - wenum), mse.row[-1] - (1:wenum)))]
		iga.df <- append(iga.df, length(dat$y)-1)
		df.col <- ifelse(iga.df >= df.col, df.col, iga.df)# ????????????????????????????????????????????????????????????????????????????????????????????????
	}else{
		mfv <- 1# ?????????????????????????????????????????????
	}

	f.col <- f.col / mfv# IGA???CIGA?????????????????????????????????F????????????
	p.col <- pf(f.col, df.col, df.col[f.denomi], lower.tail = FALSE)# p??????????????????

	# ???????????????????????????
	esmat <- NULL# ??????????????????
	esdenomis <- NULL# ?????????????????????????????????
	es.df.adjs <- NULL
	es.mse.adjs <- NULL
	ncplw <- NULL
	ncpup <- NULL
	escilw <- NULL
	esciup <- NULL
	if(eta){# ???????????????
		eta.col <- ss.col / ss.qT
		eta.col[is.na(f.denomi)] <- NA
		esmat <- cbind(esmat, "eta^2" = eta.col)
		esdenomis <- cbind(esdenomis, "eta" = ss.qT/dbase)
		if(nesci){# ??????F??????????????????????????????
			if(!is.null(bet.mse)){
				df.adj <- post.df.adj[match("eta", dimnames(post.df.adj)[[2]])]
				mse.adj <- post.mse.adj[match("eta", dimnames(post.mse.adj)[[2]])]
			}else{
				df.adj <- df.col[length(df.col)] - df.col[!is.na(f.denomi)]
				mse.adj <- (ss.qT - ss.col[!is.na(f.denomi)]) / df.adj
			}
			f.adj <- ms.col[!is.na(f.denomi)] / mse.adj
			eta.lambda <- qlambda.ncf(f.adj, df.col[!is.na(f.denomi)], df.adj, conf.level = es.conf.level)
			lambda.lw <- pmax(0, eta.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, eta.lambda$upper.limit, na.rm = TRUE)
			es.df.adjs <- cbind(es.df.adjs, "eta" = df.adj)
			es.mse.adjs <- cbind(es.mse.adjs, "eta" = mse.adj)
			ncplw <- c(ncplw, eta.lambda$lower.limit)
			ncpup <- c(ncpup, eta.lambda$upper.limit)
			escilw <- c(escilw, lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.adj + 1))
			esciup <- c(esciup, lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.adj + 1))
		}
	}
	if(peta){# ??????????????????
		peta.col <- ss.col / (ss.col + ss.col[f.denomi])
		esmat <- cbind(esmat, "p.eta^2" = peta.col)
		esdenomis <- cbind(esdenomis, "peta" = ss.col + ss.col[f.denomi])
		if(nesci){# ??????F??????????????????????????????
			peta.lambda <- qlambda.ncf(f.col[!is.na(f.denomi)], df.col[!is.na(f.denomi)], 
					df.col[na.omit(f.denomi)], conf.level = es.conf.level)
			lambda.lw <- pmax(0, peta.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, peta.lambda$upper.limit, na.rm = TRUE)
			ncplw <- c(ncplw, peta.lambda$lower.limit)
			ncpup <- c(ncpup, peta.lambda$upper.limit)
			escilw <- c(escilw, lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.col[na.omit(f.denomi)] + 1))
			esciup <- c(esciup, lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.col[na.omit(f.denomi)] + 1))
		}
	}
	if(!anyNA(geta)){# ????????????????????????
		if(!is.null(bet.mse)){# ?????????????????????????????????????????????????????????????????????????????????
			meas.row <-0
			measvec <- 1
			geta.denomi <- ss.col + post.esdenomis[match("geta", dimnames(post.esdenomis)[[2]])]
			geta.denomi[is.na(f.denomi)] <- NA
		}else if(!is.logical(geta)){# ???????????????????????????????????????????????????????????????????????????
			eff.internal <- gsub("Error", NA, gsub("Total", NA, internal.lab))
			source2int <- sapply(geta, function(x) LETTERS[match(x, factnames)])
			measfact <- unique(unlist(lapply(source2int, function(x) grep(x, eff.internal))))# ?????????????????????????????????????????????
			meas.row <- setdiff(na.omit(measfact), mse.row)# ????????????????????????
			measvec <- rep(1, eflen)
			measvec[measfact] <- 0# measfact???????????????????????????????????????????????????????????????????????????
			geta.denomi <- measvec * ss.col + sum(ss.col[c(meas.row, mse.row)])
			geta.denomi[c(mse.row, length(geta.denomi))] <- NA
		}else{
			meas.row <- 0
			measvec <- 1
			geta.denomi <- ss.col + sum(ss.col[mse.row])
			geta.denomi[c(mse.row, length(geta.denomi))] <- NA
		}
		geta.col <- ss.col / geta.denomi
		esmat <- cbind(esmat, "G.eta^2" = geta.col)
		esdenomis <- cbind(esdenomis, "geta" = geta.denomi - ss.col)
		if(nesci){# ??????F??????????????????????????????
			ss.meas <- sum(ss.col[c(meas.row, mse.row)])
			if(!is.null(bet.mse)){
				df.adj <- post.df.adj[match("geta", dimnames(post.df.adj)[[2]])]
				mse.adj <- post.mse.adj[match("geta", dimnames(post.mse.adj)[[2]])]
			}else{
				df.adj <- sum(df.col[c(meas.row, mse.row)]) + ((measvec - 1) * df.col)[!is.na(f.denomi)]
				mse.adj <- (ss.meas + ((measvec - 1) * ss.col)[!is.na(f.denomi)]) / df.adj
			}
			f.adj <- ms.col[!is.na(f.denomi)] / mse.adj
			geta.lambda <- qlambda.ncf(f.adj, df.col[!is.na(f.denomi)], df.adj, conf.level = es.conf.level)
			lambda.lw <- pmax(0, geta.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, geta.lambda$upper.limit, na.rm = TRUE)
			es.df.adjs <- cbind(es.df.adjs, "geta" = df.adj)
			es.mse.adjs <- cbind(es.mse.adjs, "geta" = mse.adj)
			ncplw <- c(ncplw, geta.lambda$lower.limit)
			ncpup <- c(ncpup, geta.lambda$upper.limit)
			escilw <- c(escilw, lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.adj + 1))
			esciup <- c(esciup, lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.adj + 1))
		}
	}
	if(eps){# ?????????????????????
		eps.col <- (ss.col - df.col * ms.col[f.denomi]) / ss.qT
		eps.col[is.na(f.denomi)] <- NA
		esmat <- cbind(esmat, "epsilon^2" = eps.col)
		esdenomis <- cbind(esdenomis, "eps" = ss.qT/dbase)
		if(nesci){# ??????F??????????????????????????????
			if(!is.null(bet.mse)){
				df.adj <- post.df.adj[match("eps", dimnames(post.df.adj)[[2]])]
				mse.adj <- post.mse.adj[match("eps", dimnames(post.mse.adj)[[2]])]
			}else{
				df.adj <- df.col[length(df.col)] - df.col[!is.na(f.denomi)]
				mse.adj <- (ss.qT - ss.col[!is.na(f.denomi)]) / df.adj
			}
			f.adj <- ms.col[!is.na(f.denomi)] / mse.adj
			eps.lambda <- qlambda.ncf(f.adj, df.col[!is.na(f.denomi)], df.adj, conf.level = es.conf.level)
			lambda.lw <- pmax(0, eps.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, eps.lambda$upper.limit, na.rm = TRUE)
			es.df.adjs <- cbind(es.df.adjs, "eps" = df.adj)
			es.mse.adjs <- cbind(es.mse.adjs, "eps" = mse.adj)
			ncplw <- c(ncplw, eps.lambda$lower.limit)
			ncpup <- c(ncpup, eps.lambda$upper.limit)
			ss.lw <- ss.qT * (lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.adj + 1))
			ss.up <- ss.qT * (lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.adj + 1))
			ms.lw <- (ss.qT - ss.lw) / df.adj
			ms.up <- (ss.qT - ss.up) / df.adj
			escilw <- c(escilw, (ss.lw - df.col[!is.na(f.denomi)] * ms.lw) / ss.qT)
			esciup <- c(esciup, (ss.up - df.col[!is.na(f.denomi)] * ms.up) / ss.qT)
		}
	}
	if(peps){# ????????????????????????
		peps.col <- (ss.col - df.col * ms.col[f.denomi]) / (ss.col + ss.col[f.denomi])
		esmat <- cbind(esmat, "p.epsilon^2" = peps.col)
		esdenomis <- cbind(esdenomis, "peps" = ss.col + ss.col[f.denomi])
		if(nesci){# ??????F??????????????????????????????
			peps.lambda <- qlambda.ncf(f.col[!is.na(f.denomi)], df.col[!is.na(f.denomi)], df.col[na.omit(f.denomi)],
				 conf.level = es.conf.level)
			lambda.lw <- pmax(0, peps.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, peps.lambda$upper.limit, na.rm = TRUE)
			ncplw <- c(ncplw, peps.lambda$lower.limit)
			ncpup <- c(ncpup, peps.lambda$upper.limit)
			ss.lw <- ss.qT * (lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.col[na.omit(f.denomi)] + 1))
			ss.up <- ss.qT * (lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.col[na.omit(f.denomi)] + 1))
			ms.lw <- (ss.qT - ss.lw) / df.col[na.omit(f.denomi)]
			ms.up <- (ss.qT - ss.up) / df.col[na.omit(f.denomi)]
			escilw <- c(escilw, (ss.lw - df.col[!is.na(f.denomi)] * ms.lw) / ss.qT)
			esciup <- c(esciup, (ss.up - df.col[!is.na(f.denomi)] * ms.up) / ss.qT)
		}
	}
	if(!anyNA(geps)){# ??????????????????????????????
		if(!is.null(bet.mse)){# ?????????????????????????????????????????????????????????????????????????????????
			meas.row <-0
			measvec <- 1
			geps.denomi <- ss.col + post.esdenomis[match("geps", dimnames(post.esdenomis)[[2]])]
			geps.denomi[is.na(f.denomi)] <- NA
		}else if(is.logical(geps) == FALSE){# ???????????????????????????????????????????????????????????????????????????
			eff.internal <- gsub("Error", NA, gsub("Total", NA, internal.lab))
			source2int <- sapply(geps, function(x) LETTERS[match(x, factnames)])
			measfact <- unique(unlist(lapply(source2int, function(x) grep(x, eff.internal))))# ?????????????????????????????????????????????
			meas.row <- setdiff(na.omit(measfact), mse.row)# ????????????????????????
			measvec <- rep(1, eflen)
			measvec[measfact] <- 0
		}else{
			meas.row <- 0
			measvec <- 1
		}
		geps.denomi <- measvec * ss.col + sum(ss.col[c(meas.row, mse.row)])
		geps.col <- (ss.col - df.col * ms.col[f.denomi]) / geps.denomi
		esmat <- cbind(esmat, "G.epsilon^2" = geps.col)
		esdenomis <- cbind(esdenomis, "geps" = geps.denomi - ss.col)
		if(nesci){# ??????F??????????????????????????????
			ss.meas <- sum(ss.col[c(meas.row, mse.row)])
			if(!is.null(bet.mse)){
				df.adj <- post.df.adj[match("geps", dimnames(post.df.adj)[[2]])]
				mse.adj <- post.mse.adj[match("geps", dimnames(post.mse.adj)[[2]])]
			}else{
				df.adj <- sum(df.col[c(meas.row, mse.row)]) + ((measvec - 1) * df.col)[!is.na(f.denomi)]
				mse.adj <- (ss.meas + ((measvec - 1) * ss.col)[!is.na(f.denomi)]) / df.adj
			}
			f.adj <- ms.col[!is.na(f.denomi)] / mse.adj
			geps.lambda <- qlambda.ncf(f.adj, df.col[!is.na(f.denomi)], df.adj, conf.level = es.conf.level)
			lambda.lw <- pmax(0, geps.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, geps.lambda$upper.limit, na.rm = TRUE)
			es.df.adjs <- cbind(es.df.adjs, "geps" = df.adj)
			es.mse.adjs <- cbind(es.mse.adjs, "geps" = mse.adj)
			ncplw <- c(ncplw, geps.lambda$lower.limit)
			ncpup <- c(ncpup, geps.lambda$upper.limit)
			ss.lw <- ss.qT * (lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.adj + 1))
			ss.up <- ss.qT * (lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.adj + 1))
			ms.lw <- (ss.qT - ss.lw) / df.adj
			ms.up <- (ss.qT - ss.up) / df.adj
			escilw <- c(escilw, (ss.lw - df.col[!is.na(f.denomi)] * ms.lw) / ss.qT)
			esciup <- c(esciup, (ss.up - df.col[!is.na(f.denomi)] * ms.up) / ss.qT)
		}
	}
	if(omega){# ???????????????????????????????????????Dodd & Schultz???1973??????????????????????????????????????????????????????
		if(!is.null(bet.mse)){# ?????????????????????????????????????????????????????????????????????????????????
			omega.denomi <- post.esdenomis[match("omega", dimnames(post.esdenomis)[[2]])]
		}else{
			omega.denomi <- sum((ss.col - df.col * ms.col[f.denomi])[!is.na(f.denomi)]) + nrow(dat) * (sum(ss.col[mse.row]) 
				/ sum(df.col[mse.row]))
		}
		omega.col <- (ss.col - df.col * ms.col[f.denomi]) / omega.denomi
		esmat <- cbind(esmat, "omega^2" = omega.col)
		esdenomis <- cbind(esdenomis, "omega" = omega.denomi/dbase)
		if(nesci){# ??????F??????????????????????????????
			if(!is.null(bet.mse)){
				df.adj <- post.df.adj[match("omega", dimnames(post.df.adj)[[2]])]
				mse.adj <- post.mse.adj[match("omega", dimnames(post.mse.adj)[[2]])]
			}else{
				df.adj <- df.col[length(df.col)] - df.col[!is.na(f.denomi)]
				mse.adj <- (ss.qT - ss.col[!is.na(f.denomi)]) / df.adj
			}
			f.adj <- ms.col[!is.na(f.denomi)] / mse.adj
			omega.lambda <- qlambda.ncf(f.adj, df.col[!is.na(f.denomi)], df.adj, conf.level = es.conf.level)
			lambda.lw <- pmax(0, omega.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, omega.lambda$upper.limit, na.rm = TRUE)
			ncplw <- c(ncplw, omega.lambda$lower.limit)
			ncpup <- c(ncpup, omega.lambda$upper.limit)
			es.df.adjs <- cbind(es.df.adjs, "omega" = df.adj)
			es.mse.adjs <- cbind(es.mse.adjs, "omega" = mse.adj)
			ss.lw <- ss.qT * (lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.adj + 1))
			ss.up <- ss.qT * (lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.adj + 1))
			ms.lw <- (ss.qT - ss.lw) / df.adj
			ms.up <- (ss.qT - ss.up) / df.adj
			escilw <- c(escilw, (ss.lw - df.col[!is.na(f.denomi)] * ms.lw) / (ss.qT + ms.lw))
			esciup <- c(esciup, (ss.up - df.col[!is.na(f.denomi)] * ms.up) / (ss.qT + ms.up))
		}
	}
	if(omegana){# ??????????????????????????????????????????Dodd & Schultz???1973?????????????????????????????????????????????????????????
		if(!is.null(bet.mse)){# ?????????????????????????????????????????????????????????????????????????????????
			omegana.denomi <- post.esdenomis[match("omegana", dimnames(post.esdenomis)[[2]])]
		}else if(length(mse.row) == 1){# ???????????????????????????
			omegana.denomi <- sum((ss.col - df.col * ms.col[f.denomi])[!is.na(f.denomi)]) + sum(cellN * ms.col[mse.row])
		}else{# ???????????????????????????
			dflev <- flev[(betlen + 1):length(flev)]
			omega.dummy <- cellN * c(1, unlist(sapply(1:length(dflev), function(y) combn(1:length(dflev), y, function(x) 
				prod(dflev[x])))))
			omegana.denomi <- sum((ss.col - df.col * ms.col[f.denomi])[!is.na(f.denomi)]) + sum(omega.dummy * ms.col[mse.row])
		}
		omegana.col <- (ss.col - df.col * ms.col[f.denomi]) / omegana.denomi
		esmat <- cbind(esmat, "omega^2_NA" = omegana.col)
		esdenomis <- cbind(esdenomis, "omegana" = omegana.denomi/dbase)
		if(nesci){
			ncplw <- c(ncplw, rep(NA, sum(!is.na(f.col))))
			ncpup <- c(ncpup, rep(NA, sum(!is.na(f.col))))
			escilw <- c(escilw, rep(NA, sum(!is.na(gomegana.col))))
			esciup <- c(esciup, rep(NA, sum(!is.na(gomegana.col))))
		}
	}
	if(pomega){# ??????????????????
		pomega.col <- (ss.col - df.col * ms.col[f.denomi]) / (ss.col - df.col * ms.col[f.denomi] + nrow(dat) * ms.col[f.denomi])
		esmat <- cbind(esmat, "p.omega^2" = pomega.col)
		esdenomis <- cbind(esdenomis, "pomega" = ss.col - df.col * ms.col[f.denomi] + nrow(dat) * ms.col[f.denomi])
		if(nesci){# ??????F??????????????????????????????
			pomega.lambda <- qlambda.ncf(f.col[!is.na(f.denomi)], df.col[!is.na(f.denomi)], df.col[na.omit(f.denomi)], conf.level = es.conf.level)
			lambda.lw <- pmax(0, pomega.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, pomega.lambda$upper.limit, na.rm = TRUE)
			ncplw <- c(ncplw, pomega.lambda$lower.limit)
			ncpup <- c(ncpup, pomega.lambda$upper.limit)
			ss.lw <- ss.qT * (lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.col[na.omit(f.denomi)] + 1))
			ss.up <- ss.qT * (lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.col[na.omit(f.denomi)] + 1))
			ms.lw <- (ss.qT - ss.lw) / df.col[na.omit(f.denomi)]
			ms.up <- (ss.qT - ss.up) / df.col[na.omit(f.denomi)]
			escilw <- c(escilw, (ss.lw - df.col[!is.na(f.denomi)] * ms.lw) / (ss.qT + ms.lw))
			esciup <- c(esciup, (ss.up - df.col[!is.na(f.denomi)] * ms.up) / (ss.qT + ms.up))
		}
	}
	if(!anyNA(gomega)){# ?????????????????????????????????????????????
		if(!is.null(bet.mse)){# ?????????????????????????????????????????????????????????????????????????????????
			gomega.denomi <- (ss.col - df.col * ms.col[f.denomi]) + post.esdenomis[match("gomega", dimnames(post.esdenomis)[[2]])]
			gomega.denomi[is.na(f.denomi)] <- NA
		}else if(is.logical(gomega) == FALSE){# ???????????????????????????????????????????????????????????????????????????
			eff.internal <- gsub("Error", NA, gsub("Total", NA, internal.lab))
			source2int <- sapply(gomega, function(x) LETTERS[match(x, factnames)])
			measfact <- unique(unlist(lapply(source2int, function(x) grep(x, eff.internal))))# ?????????????????????????????????????????????
			meas.row <- setdiff(na.omit(measfact), mse.row)# ????????????????????????
			measvec <- rep(1, eflen)
			measvec[measfact] <- 0
			gomega.denomi <- (measvec * (ss.col - df.col * ms.col[f.denomi]) + sum(ss.col[meas.row] - df.col[meas.row] * 
				ms.col[f.denomi][meas.row]) + nrow(dat) * (sum(ss.col[mse.row])/sum(df.col[mse.row])))
		}else{
			meas.row <- 0
			measvec <- 1
			gomega.denomi <- (measvec * (ss.col - df.col * ms.col[f.denomi]) + sum(ss.col[meas.row] - df.col[meas.row] * 
				ms.col[f.denomi][meas.row]) + nrow(dat) * (sum(ss.col[mse.row])/sum(df.col[mse.row])))
		}
		gomega.col <- (ss.col - df.col * ms.col[f.denomi]) / gomega.denomi
		esmat <- cbind(esmat, "G.omega^2" = gomega.col)
		esdenomis <- cbind(esdenomis, "gomega" = gomega.denomi - (ss.col - df.col * ms.col[f.denomi]))
		if(nesci){# ??????F??????????????????????????????
			ss.meas <- sum(ss.col[c(meas.row, mse.row)])
			if(!is.null(bet.mse)){
				df.adj <- post.df.adj[match("gomega", dimnames(post.df.adj)[[2]])]
				mse.adj <- post.mse.adj[match("gomega", dimnames(post.mse.adj)[[2]])]
			}else{
				df.adj <- sum(df.col[c(meas.row, mse.row)]) + ((measvec - 1) * df.col)[!is.na(f.denomi)]
				mse.adj <- (ss.meas + ((measvec - 1) * ss.col)[!is.na(f.denomi)]) / df.adj
			}
			f.adj <- ms.col[!is.na(f.denomi)] / mse.adj
			gomega.lambda <- qlambda.ncf(f.adj, df.col[!is.na(f.denomi)], df.adj, conf.level = es.conf.level)
			lambda.lw <- pmax(0, gomega.lambda$lower.limit, na.rm = TRUE)
			lambda.up <- pmax(0, gomega.lambda$upper.limit, na.rm = TRUE)
			es.df.adjs <- cbind(es.df.adjs, "gomega" = df.adj)
			es.mse.adjs <- cbind(es.mse.adjs, "gomega" = mse.adj)
			ncplw <- c(ncplw, gomega.lambda$lower.limit)
			ncpup <- c(ncpup, gomega.lambda$upper.limit)
			ss.lw <- ss.qT * (lambda.lw / (lambda.lw + df.col[!is.na(f.denomi)] + df.adj + 1))
			ss.up <- ss.qT * (lambda.up / (lambda.up + df.col[!is.na(f.denomi)] + df.adj + 1))
			ms.lw <- (ss.qT - ss.lw) / df.adj
			ms.up <- (ss.qT - ss.up) / df.adj
			escilw <- c(escilw, (ss.lw - df.col[!is.na(f.denomi)] * ms.lw) / (ss.qT + ms.lw))
			esciup <- c(esciup, (ss.up - df.col[!is.na(f.denomi)] * ms.up) / (ss.qT + ms.up))
		}
	}
	if(!anyNA(gomegana)){# ????????????????????????????????????????????????
		if(length(mse.row) == 1){# ???????????????????????????
			omega.dummy <- cellN
		}else{# ???????????????????????????
			dflev <- flev[(betlen + 1):length(flev)]
			omega.dummy <- cellN * c(1, unlist(sapply(1:length(dflev), function(y) combn(1:length(dflev), y, function(x) prod(dflev[x])))))
		}
		if(is.logical(gomegana) == FALSE){# ???????????????????????????????????????????????????????????????????????????
			eff.internal <- gsub("Error", NA, gsub("Total", NA, internal.lab))
			source2int <- sapply(gomegana, function(x) LETTERS[match(x, factnames)])
			measfact <- unique(unlist(lapply(source2int, function(x) grep(x, eff.internal))))# ?????????????????????????????????????????????
			meas.row <- setdiff(na.omit(measfact), mse.row)# ????????????????????????
			ss.meas <- sum(ss.col[setdiff(measfact, mse.row)] - df.col[setdiff(measfact, mse.row)] * ms.copy[setdiff(measfact, mse.row)])
			measvec <- rep(1, eflen)
			measvec[measfact] <- 0
		}else{
			meas.row <- 0
			measvec <- 1
		}
		ms.copy <- ms.col[f.denomi]
		gomegana.denomi <- measvec * (ss.col - df.col * ms.col[f.denomi]) + sum(ss.col[meas.row] - df.col[meas.row] * ms.copy[meas.row]) + sum(omega.dummy * ms.col[mse.row])
		if(!is.null(bet.mse)){# ?????????????????????????????????????????????????????????????????????????????????
			gomegana.denomi <- (ss.col - df.col * ms.col[f.denomi]) + post.esdenomis[match("gomegana", dimnames(post.esdenomis)[[2]])]
			gomegana.denomi[is.na(f.denomi)] <- NA
		}
		gomegana.col <- (ss.col - df.col * ms.col[f.denomi]) / gomegana.denomi
		esmat <- cbind(esmat, "G.omega^2_NA" = gomegana.col)
		esdenomis <- cbind(esdenomis, "gomegana" = gomegana.denomi - (ss.col - df.col * ms.col[f.denomi]))
		if(nesci){
			ncplw <- c(ncplw, rep(NA, sum(!is.na(f.col))))
			ncpup <- c(ncpup, rep(NA, sum(!is.na(f.col))))
			escilw <- c(escilw, rep(NA, sum(!is.na(f.col))))
			esciup <- c(esciup, rep(NA, sum(!is.na(f.col))))
		}
	}
	if(prep){# p_rep????????????
		prep.col <- pmin(0.9999, pnorm(qnorm(1 - p.col/2) / sqrt(2)))
		esmat <- cbind(esmat, "p_rep" = prep.col)
	}

	# ???????????????
	if(esboot){# ??????????????????????????????????????????????????????????????????
		if(is.na(inter)){# ??????????????????
			eslist <- as.vector(esmat[-c(mse.row, length(df.col)), ])
			return(list("eslist" = eslist, "bet.mse" = c(NA, sum(ss.col[mse.row]), sum(df.col[mse.row])), 
				"ss.qT" = ss.qT, "esdenomis" = esdenomis))
		}else{# ?????????????????????????????????
			eslist <- as.vector(esmat[charmatch(inter, internal.lab), ])
			return(eslist)
		}
	}else{# ??????????????????
		sig.col <- sig.sign(p.col)# p????????????????????????????????????????????????????????????
		nesci.info1 <- NA
		nescitab <- NA
		if(is.null(esmat)){
			anovatab <- data.frame(source.col, ss.col, df.col, ms.col, f.col, p.col, sig.col, row.names = NULL)# ???????????????????????????????????????????????????
		}else{
			anovatab <- data.frame(source.col, ss.col, df.col, ms.col, f.col, p.col, sig.col, esmat, row.names = NULL)# ??????????????????????????????????????????
			names(anovatab)[8:ncol(anovatab)] <- dimnames(esmat)[[2]]
			if(nesci){# ??????F???????????????????????????????????????????????????????????????
				fcomlen <- sum(choose(maxfact, 1:maxfact))
				nesci.info1 <- c("=== Noncentral F Distribution-Based Confidence Intervals for Effect Sizes ===", paste0("=== ", 100 * es.conf.level, "% confidence intervals are calculated. ==="))
				nescitab <- data.frame("ES" = rep(dimnames(esmat)[[2]], each = sum(!is.na(f.col))), 
					"Source" = source.col[-c(mse.row, length(source.col))], "Estimate" = as.vector(esmat[!is.na(f.col), ]), 
					"CI_L" = escilw, "CI_U" = esciup, "ncp_L" = ncplw, "ncp_U" = ncpup, row.names = NULL)
				if(withlen > 0){# ?????????????????????????????????
					nesci.info1 <- c(nesci.info1, "*** CAUTION! Non-central parameters are not estimated for repeated-measures effects because their distributions are unknown. ***")
					if(betlen > 0){
						bcomlen <- sum(choose(betlen, 1:betlen)) * min(1, betlen)
						nescitab[-unlist(lapply(0:(nrow(nescitab)/fcomlen - 1), function(x) 1:bcomlen + x * fcomlen)), 4:7] <- NA
					}else{
						nescitab[, 4:7] <- NA
					}
				}
			}
		}
		if(is.na(inter)){# inter???????????????????????????anovatab???mse.row?????????
			if(withlen > 0) epsitab$Effect <- epsi.effect[(2 * sum(withlen == 1)):length(epsi.effect)]# ???????????????????????????Global????????????
			return(list("epsi.info1" = epsi.info1, "epsitab" = epsitab, "ano.info1" = ano.info1, "anovatab" = anovatab, 
				"mse.row" = mse.row, "internal.lab" = internal.lab, "dmat" = sres$dmat, "flev" = flev, "cellN" = cellN, 
				"full.elem" = full.elem, "epsi.effect" = epsi.effect, "nesci.info1" = nesci.info1, "nescitab" = nescitab, 
				"esdenomis" = esdenomis, "es.df.adjs" = es.df.adjs, "es.mse.adjs" = es.mse.adjs))
		}else{# ???????????????????????????intertab?????????
			# ???????????????????????????????????????????????????
			sim.row <- charmatch(inter, internal.lab)
			intertab <- rbind(anovatab[sim.row, ], anovatab[f.denomi[sim.row], ])
			if(nesci){
				sim.esrow <- charmatch(inter, internal.lab[-c(mse.row, length(source.col))])
				nescitab <- nescitab[sim.esrow + fcomlen * 0:(nrow(nescitab)/fcomlen - 1), ]
			}

			# ??????????????????????????????inter????????????????????????????????????
			if(charmatch(inter, strsplit(design, "")[[1]]) < charmatch("s", strsplit(design, "")[[1]])){
				# ????????????????????????NA???????????????
				if(iga || ciga) interepsi <- rep(NA, 11)# IGA???CIGA????????????????????????????????????
				else interepsi <- rep(NA, 10)
			}else{
				interepsi <- epsitab[charmatch(inter, epsitab$Effect), ]
			}
			return(list("intertab" = intertab, "interepsi" = interepsi, "internal.lab" = internal.lab, 
				"dmat" = sres$dmat, "flev" = flev, "cellN" = cellN, "nescitab" = nescitab))
		}
	}
}


# ????????????????????????????????????????????????????????????
mpginv <- function (xmat, tol = .Machine$double.eps^(2/3)){
	sx <- svd(xmat)
	pv <- (sx$d > max(tol * sx$d[1], 0))
	if(all(pv)){
		invmat <- sx$v %*% (1/sx$d * t(sx$u))
	}else if(any(pv)){
		invmat <- sx$v[, pv, drop = FALSE] %*% (1/sx$d[pv] * t(sx$u[, pv, drop = FALSE]))
    }else{
		invmat <- array(0, c(ncol(xmat), nrow(xmat)))
	}
	return(invmat)
}


# Welch-James??????????????????????????????????????????????????????
# pairwise?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# Lix, L. M., & Keselman, H. J. (1995). Approximate degrees of freedom tests: A unified perspective on testing for mean equality. Psychological Bulletin, 117, 547-560.
wj.calc <- function(dat, design, pairwise = NA){
	maxfact <- nchar(design) - 1# ???????????????????????????????????????
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????
	flev <- sapply(2:nchar(design), function(x) nlevels(dat[, x]))# ?????????????????????
	ol <- prod(flev[min(1, betlen):betlen])# ?????????????????????????????????????????????????????????
	rl <- ifelse(withlen == 0, 1, prod(flev[(betlen+1):maxfact]))# ?????????????????????????????????????????????????????????

	# ?????????????????????????????????????????????????????????
	if(withlen == 0){
		reppat <- rep(1, nrow(dat))# ????????????????????????????????????????????????
	}else{
		reppat <- interaction(dat[, maxfact:(betlen+1) + 1])# ???????????????????????????????????????????????????
	}

	# ????????????????????????????????????????????????????????????
	if(betlen == 0){# ???????????????????????????????????????????????????????????????????????????
		othN <- length(unique(dat$s))# ?????????????????????
		mdmat <- do.call(cbind, tapply(dat$y, reppat, function(x) x - mean(x, na.rm = TRUE)))# ????????????
		smat <- crossprod(mdmat)/(othN - 1)/othN# ?????????????????????????????????????????????????????????
	}else{# ?????????????????????????????????????????????????????????????????????????????????
		othnum <- (betlen:1) + 1# ?????????????????????????????????????????????????????????????????????????????????
		othN <- as.vector(table(dat[names(dat)[othnum]]) / rl)# ??????????????????????????????????????????????????????????????????????????????????????????
		rdat <- cbind(dat, "reppat" = reppat)# ???????????????????????????????????????
		mdmat <- lapply(split(rdat, rdat[names(rdat)[othnum]]), function(x) do.call(cbind, tapply(x$y, x$reppat, function(w) w - mean(w, na.rm = TRUE))))# ????????????
		covmat <- lapply(1:ol, function(x) crossprod(mdmat[[x]])/(othN[x] - 1)/othN[x])# ?????????????????????????????????????????????????????????
		smat <- do.call(rbind, lapply(1:ol, function(x) t(diag(ol)[x, ]) %x% covmat[[x]]))# ???????????????????????????
	}

	# ???????????????????????????????????????????????????
	factcomb <- expand.gmatrix(replicate(maxfact, list(0:1)))[-1, , drop = FALSE]# ?????????????????????????????????
	labbase <- apply(factcomb, 1, function(x) paste0(LETTERS[1:maxfact][x == 1], sep = ":", collapse = ""))
	comblabel <- sapply(labbase, function(x) substr(x, 1, nchar(x) - 1))# ?????????????????????
	names(comblabel) <- NULL
	labord <- order(nchar(comblabel), comblabel)
	factcomb <- factcomb[labord, , drop = FALSE]# ????????????????????????????????????????????????????????????????????????
	comblabel <- comblabel[labord]# ????????????????????????????????????
	row.names(factcomb) <- comblabel# ???????????????????????????????????????????????????
	rmat <- lapply(flev, function(x) cbind(1, -1 * diag(x - 1)))# ????????????????????????????????????????????????????????????
	rvec <- lapply(flev, function(x) array(1, c(1, x)))# ?????????????????????????????????????????????????????????????????????

	# ???????????????????????????????????????
	if(is.na(pairwise)){# ??????????????????????????????????????????????????????
		adf.R <- lapply(1:nrow(factcomb), function(x) Reduce(f = kronecker, x = ifelse(factcomb[x, ] == 1, rmat, rvec)))
	}else{# ??????????????????????????????????????????????????????????????????????????????????????????
		bonl <- nlevels(dat[, pairwise])
		bon.name <- combn(bonl, 2, function(x) paste0(levels(dat[, pairwise])[x][1], "-", levels(dat[, pairwise])[x][2]))
		contbase <- c(1, -1, rep(0, bonl - 2))
		contpairs <- combn(bonl, 2, function(x) array(contbase[order(c(x, setdiff(1:bonl, x)))], c(1, bonl)), simplify = FALSE)
		contfacts <- rep(1, maxfact)
		contfacts[match(pairwise, names(dat))-1] <- 0
		adf.R <- lapply(1:length(contpairs), function(x) Reduce(f = kronecker, x = ifelse(contfacts == 1, rvec, contpairs[x])))
	}

	# ???????????????????????????????????????
	qbase <- c(1, rep(0, ol - 1))
	adf.Q <- lapply(1:ol, function(x) diag(rep(qbase[order(c(x, setdiff(1:ol, x)))], each = rl)))

	# ?????????????????????
	mu <- as.vector(tapply(dat$y, dat[, (maxfact+1):2], function(x) mean(x, na.rm = TRUE)))
	adf.T <- sapply(adf.R, function(x) t(x %*% mu) %*% (mpginv(x %*% smat %*% t(x))) %*% (x %*% mu))
	innmat <- lapply(adf.R, function(x) lapply(adf.Q, function(w) (smat %*% t(x)) %*% (mpginv(x %*% smat %*% t(x))) %*% (x %*% w)))
	adf.A <- sapply(innmat, function(x) sum(sapply(x, function(w) sum(diag(w %*% w)) + sum(diag(w))^2) / (othN - 1))/2)

	adf.df1 <- sapply(adf.R, function(x) nrow(x))
	adf.cvals <- adf.df1 + 2 * adf.A - (6 * adf.A) / (adf.df1 + 2)
	adf.df2 <- adf.df1 * (adf.df1 + 2) / (3 * adf.A)

	# ?????????????????????????????????????????????
	if(is.na(pairwise)){
		pvals <- pf(adf.T/adf.cvals, adf.df1, adf.df2, lower.tail = FALSE)
		wjtab <- data.frame("Source" = comblabel, "approx.F" = adf.T/adf.cvals, "df1" = adf.df1, 
			"df2" = adf.df2, "p.value" = pvals, "sig.col" = sig.sign(pvals))
	}else{
		wjtab <- data.frame("pair" = bon.name, "t" = sqrt(adf.T/adf.cvals), "df" = adf.df2, 
			"p.value" = pt(sqrt(adf.T/adf.cvals), adf.df2, lower.tail = FALSE) * 2)
	}
	return(wjtab)
}


# ??????Bonferroni????????????Holm????????????Shaffer????????????Holland-Copenhaver????????????????????????????????????????????????
# ??????????????????Shaffer????????????????????????holm = T????????????Holm????????????hc = T????????????Holland-Copenhaver????????????????????????
# s2r = T???s2d = T?????????????????????????????????????????????????????????????????????????????????????????????Shaffer????????????????????????
mod.Bon <- function(dat, design, taref, bet.mse = NA, factlabel = NA, factnames = NA, type2 = FALSE, holm = FALSE, hc = FALSE, 
	s2r = FALSE, s2d = FALSE, fs1 = FALSE, fs2r = FALSE, fs2d = FALSE, welch = FALSE, alpha = 0.05, criteria = FALSE){
	# factnames???????????????????????????????????????????????????
	if(anyNA(factnames)) factnames <- LETTERS[1:(nchar(design)-1)]

	# ??????????????????????????????????????????
	if(is.na(factlabel)) factlabel <- taref

	bonl <- nlevels(dat[, taref])# ??????????????????
	h0size <- bonl * (bonl-1)/2# ?????????????????????
	comb.frame <- combn(bonl, 2)# ???????????????????????????????????????
	tarlevs <- levels(dat[, taref])
	bon.name <- apply(comb.frame, 2, function(x) paste0(tarlevs[x][1], "-", tarlevs[x][2]))# ?????????????????????
	bon.num <- match(taref, names(dat))-1# ????????????????????????????????????????????????????????????

	# ???????????????????????????
	cont.means <- tapply(dat$y, dat[, 2:nchar(design)], mean)# ??????????????????????????????
	bon.means <- apply(cont.means, bon.num, mean)# ?????????????????????????????????????????????

	factlevels <- sapply(names(dat), function(x) nlevels(dat[, x]))# ?????????????????????
	factlevels[match(taref, names(dat))] <- 2# ???????????????????????????????????????????????????????????????
	factlevels <- factlevels[!(factlevels == factlevels[1] | factlevels == factlevels[length(factlevels)])]# ??????????????????s???y??????????????????

	cont.N <- table(dat[, 2:nchar(design)])# ????????????????????????
	bon.denomi <- apply(1/cont.N, bon.num, mean) / (prod(factlevels)/2)# ?????????????????????????????????????????????????????????????????????????????????????????????
	bon.delta <- bon.means[comb.frame[1, ]] - bon.means[comb.frame[2, ]]# ????????????

	# ??????????????????????????????????????????
	if(welch){
		bontab <- wj.calc(dat, design, pairwise = taref)
		bon.p <- bontab$p.value
		bontab <- cbind(bontab[, 1, drop = FALSE], "difference" = bon.delta, bontab[, 2:4, drop = FALSE])
		rcomb.frame <- comb.frame[, order(bontab$p.value)]
		bontab <- bontab[order(bontab$p.value), ]# p?????????????????????????????????
		bon.info2 <- "== Keselman-Keselman-Shaffer Statistics and Satterthwaite's Degrees of Freedom =="
	}else{
		# ????????????????????????????????????????????????????????????????????????????????????????????????????????????
		if(length(bet.mse) != 1){
			# ????????????????????????????????????????????????MSe???????????????
			bon.df <- bet.mse$df.col# ?????????
			bon.Ve <- bet.mse$ms.col# ????????????
			bon.info2 <- paste0("== The factor < ", factlabel, " > is analysed as independent means. ==")
		}else{
			# ????????????????????????????????????????????????????????????MSe??????????????????
			bon.lev <- combn(levels(dat[, taref]), 2, function(x) x)# ???????????????????????????
			subdat <- apply(bon.lev, 2, function(x) dat[dat[, taref] == x[1] | dat[, taref] == x[2], ])# ????????????????????????????????????????????????????????????????????????????????????????????????????????????
			for(i in 1:length(subdat)){
				subdat[[i]][, taref] <- subdat[[i]][, taref][, drop = TRUE]
			}
			bon.anova <- lapply(subdat, function(x) anova.modeler(dat = x, design = design, factnames = factnames, type2 = type2, 
				inter = taref)$intertab[2, ])
			bon.df <- sapply(bon.anova, function(x) x$df.col)# ?????????
			bon.Ve <- sapply(bon.anova, function(x) x$ms.col)
			bon.info2 <- paste0("== The factor < ", factlabel, " > is analysed as dependent means. ==")
		}

		# ?????????????????????????????????
		bon.SE <- sqrt((bon.denomi[comb.frame[1, ]] + bon.denomi[comb.frame[2, ]]) * bon.Ve)
		bon.t <- abs(bon.delta / bon.SE)# ???????????????????????????
		bon.p <- pt(bon.t, bon.df, lower.tail = FALSE) * 2# ????????????

		# ?????????????????????????????????????????????
		bontab <- data.frame("pair" = bon.name, "difference" = bon.delta, "t" = bon.t, "df" = bon.df, "p.value" = bon.p)
		rcomb.frame <- comb.frame[, order(bontab$p.value)]
		bontab <- bontab[order(bontab$p.value), ]# p?????????????????????????????????
	}

	# ???????????????????????????????????????
	if(holm){
		p.criteria <- h0size:1# Holm????????????????????????
		bon.info1 <- paste0("== Holm's Sequentially Rejective Bonferroni Procedure ==")

	}else if(s2d || fs2d){# Donoguhe???2004?????????????????????????????????????????????Shaffer??????????????????????????????????????????????????????
		# Donoghue, J. R. (2004). Implementing Shaffer's multiple comparison procedure for a large number of groups.
		# Recent developments in multiple comparison procedures (Institute of mathematical statistics-Lecture Notes-Monograph Series, 47), pp. 1-23.
		# Donoghue???????????????????????????????????????????????????

		# ?????????????????????
		bon.comb <- comb.frame# ???????????????????????????
		bon.comb <- bon.comb[, order(bon.p)]# ???????????????????????????
		hvec <- 1:bonl
		a.mat <- diag(rep(0, bonl))

		shaf.value <- c(h0size, rep(NA, h0size - 1))# ??????????????????????????????????????????????????????????????????
		allcomb <- unlist(lapply((bonl-1):1, function(y) combn(bonl, y, function(x) x, simplify = FALSE)), recursive = FALSE)# ????????????????????????????????????????????????????????????

		for(j in 1:(h0size-1)){
			# ???????????????????????????????????????????????????
			a.mat[bon.comb[1, j], bon.comb[2, j]] <- 1# ???????????????????????????????????????????????????
			a.mat[bon.comb[2, j], bon.comb[1, j]] <- 1# ?????????????????????????????????????????????

			# ???????????????????????????
			# ???????????????????????????????????????????????????????????????????????????????????????
			# ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
			undiff <- array(rep(0, bonl), c(bonl, 1))# ?????????
			cnt <- 1
			while(cnt <= length(allcomb)){
				hnum <- allcomb[[cnt]]
				if(max(colSums(undiff[hnum, , drop = FALSE])) == length(hnum)){
				# ??????????????????????????????????????????????????????????????????????????????
					cnt <- cnt + 1
				}else if(sum(a.mat[hnum, hnum]) == 0){
				# ?????????????????????????????????????????????????????????????????????
					undiff <- cbind(undiff, 1 - 0^match(hvec, hnum, nomatch = 0))
					cnt <- cnt + 1
				}else{
				# ???????????????????????????????????????????????????????????????????????????????????????allcomb???????????????
					allcomb <- allcomb[-cnt]
				}
			}

			undiff <- undiff[, -1]# ??????????????????????????????
			gsize <- colSums(undiff)# ????????????????????????????????????????????????

			# sig.min???????????????
			sig.min <- max(gsize)^2# ?????????????????????????????????????????????
			nxcand <- undiff# ??????????????????????????????
			gi <- 1
			while(ncol(nxcand) > 1 && nrow(nxcand) > 1){
				nxcand <- nxcand[(1:nrow(nxcand))[nxcand[, gi] == 0], , drop = FALSE]
				lengvec <- colSums(nxcand)# ????????????????????????
				sig.min <- sig.min + max(lengvec)^2# ????????????????????????????????????????????????
				gi <- which.max(lengvec)# ????????????????????????
			}

			# don.max???????????????
			don.smax <- sig.min

			for(i in 2:min(ncol(undiff)-1, bonl)){
				don.sig <- gsize[i]^2
				nxcand <- undiff
				gi <- i
				while(ncol(nxcand) > 1 && nrow(nxcand) > 1){
					nxcand <- nxcand[(1:nrow(nxcand))[nxcand[, gi] == 0], , drop = FALSE]
					lengvec <- colSums(nxcand)# ????????????????????????
					don.sig <- don.sig + max(lengvec)^2# ????????????????????????????????????????????????
					gi <- which.max(lengvec)# ????????????????????????
				}
				don.smax <- max(don.sig, don.smax)# ???????????????????????????
			}
			shaf.value[j+1] <- (don.smax - bonl) / 2
		}

		if(s2d){
			p.criteria <- shaf.value# Shaffer????????????????????????
			bon.info1 <- paste0("== Shaffer's Modified Sequentially Rejective Bonferroni Procedure [SPECIFIC] ==", "\n", 
				"== This computation is based on the algorithm by Donoghue (2004). ==")
			shaf.meth <- paste0(" [SPECIFIC] ==", "\n", "== This computation is based on the algorithm by Donoghue (2004). ==")
		}else{
			p.criteria <- c(shaf.value[2], shaf.value[2:length(shaf.value)])# F-Shaffer????????????????????????
			bon.info1 <- paste0("== Shaffer's F-Modified Sequentially Rejective Bonferroni Procedure [SPECIFIC] ==", "\n", 
				"== This computation is based on the algorithm by Donoghue (2004). ==")
			shaf.meth <- paste0(" [SPECIFIC] ==", "\n", "== This computation is based on the algorithm by Donoghue (2004). ==")
		}

	}else{# Rasmussen???1993?????????????????????????????????Shaffer??????????????????????????????????????????????????????
		# Rasmussen, J. L. (1993). Algorithm for Shaffer's multiple comparison tests. Educational and Psychological Measurement, 53, 329-335.

		# ??????????????????????????????????????????????????????
		hpattern <- 2^(bonl-1)# ??????????????????????????????????????????
		nbuffer <- 2^((bonl-2):0)
		c.mat <- cbind(rep(0, hpattern), sapply(nbuffer, function(x) rep(rep(0:1, each = x), nbuffer[1]/x)))
		c.mat <- sapply(1:ncol(c.mat), function(x) rowSums(c.mat[, 1:x, drop = FALSE]))

		f.mat <- 1 * combn(bonl, 2, function(x) c.mat[, x[1]] != c.mat[, x[2]])# ?????????????????????????????????????????????????????????????????????????????????????????????????????????
		rebon.p <- bon.p[order(combn(rank(bon.means), 2, function(x) prod(x)))]# ???????????????????????????????????????????????????????????????
		f.mat <- f.mat[, order(rebon.p)]# ??????????????????????????????????????????
		i.vector <- rowSums(f.mat)# ?????????????????????????????????
		t.vector <- h0size - i.vector# ???????????????????????????????????????

		if(s2r || fs2r){# ???????????????????????????????????????????????????????????????????????????????????????????????????
			shaf.value <- c(max(t.vector), max(t.vector[i.vector >= (2 - 1)][(f.mat[i.vector >= (2 - 1), 1:(2-1)]) == (2 - 1)]))
			shaf.value <- c(shaf.value, sapply(3:h0size, function(x) max(t.vector[i.vector >= (x - 1)][rowSums(f.mat[i.vector >= (x - 1), 1:(x-1)]) == (x - 1)])))
			shaf.meth <- paste0(" [SPECIFIC] ==", "\n", "== This computation is based on the algorithm by Rasmussen (1993). ==")
		}else{# ???????????????????????????????????????????????????????????????????????????????????????????????????
			shaf.value <- sapply(1:h0size, function(x) max(t.vector[i.vector >= (x - 1)]))
			shaf.meth <- " =="
		}

		if(fs1 || fs2r){
			p.criteria <- c(shaf.value[2], shaf.value[2:length(shaf.value)])# F-Shaffer????????????????????????
			bon.info1 <- paste0("== Shaffer's F-Modified Sequentially Rejective Bonferroni Procedure", shaf.meth)
		}else{
			p.criteria <- shaf.value# Shaffer????????????????????????
			bon.info1 <- paste0("== Shaffer's Modified Sequentially Rejective Bonferroni Procedure", shaf.meth)
		}
	}

	# ?????????????????????????????????????????????????????????????????????
	diff.direct <- ifelse(bontab$difference <= 0, " < ", " > ")
	bon.differ <- paste0(tarlevs[rcomb.frame[1, ]], diff.direct, tarlevs[rcomb.frame[2, ]])
	# ??????????????????????????????????????????????????????????????????
	bon.equal <- paste0(tarlevs[rcomb.frame[1, ]], " = ", tarlevs[rcomb.frame[2, ]])

	if(criteria){# ??????????????????????????????????????????????????????????????????
		if(hc){
			bontab <- transform(bontab, "criteria" = 1 - (1 - alpha) ^ (1/p.criteria))# Sidak??????????????????????????????????????????
			if(holm == TRUE) bon.info1 <- paste0("== Holm's Sequentially Rejective Sidak Procedure ==")
			else bon.info1 <- paste0("== Holland-Copenhaver's Improved Sequentially Rejective Sidak Procedure", shaf.meth)

			if(length(bet.mse) == 1) bon.info1 <- append(bon.info1, "*** CAUTION! This procedure might be inappropriate for dependent means. ***")
		}else{
			bontab <- transform(bontab, "criteria" = alpha/p.criteria)# Bonferroni??????????????????????????????????????????
		}
		# ??????????????????????????????????????????????????????????????????????????????
		bon.sign <- ifelse(cummin(bontab$p.value < bontab$criteria), paste(bon.differ, "*", sep = " "), paste(bon.equal, " ", sep = " "))
	}else{# ????????????????????????????????????????????????????????????
		if(hc){
			bontab <- transform(bontab, "adj.p" = pmin(1, cummax((1-(1-bontab$p.value)^p.criteria))))# Sidak???????????????????????????????????????
			if(holm == TRUE) bon.info1 <- paste0("== Holm's Sequentially Rejective Sidak Procedure ==")
			else bon.info1 <- paste0("== Holland-Copenhaver's Improved Sequentially Rejective Sidak Procedure", shaf.meth)

			if(length(bet.mse) == 1) bon.info1 <- append(bon.info1, "*** CAUTION! This procedure might be inappropriate for dependent means. ***")
		}else{
			bontab <- transform(bontab, "adj.p" = pmin(1, cummax(bontab$p.value * p.criteria)))# Bonferroni???????????????????????????????????????
		}
		# ??????????????????????????????????????????????????????????????????????????????
		bon.sign <- ifelse(bontab$adj.p < alpha, paste(bon.differ, "*", sep = " "), paste(bon.equal, " ", sep = " "))
	}

	# ???????????????????????????????????????????????????
	bontab <- transform(bontab, "significance" = bon.sign)

	# ????????????????????????
	b.sncol <- tapply(dat$y, dat[, taref], length)# ????????????????????????????????????
	b.sdcol <- tapply(dat$y, dat[, taref], sd)# ????????????????????????????????????
	bonstat <- data.frame("Dummy" = levels(dat[, taref]), "n" = b.sncol, "Mean" = bon.means, "S.D." = b.sdcol)
	names(bonstat)[1] <- factlabel# ???????????????????????????factlabel??????????????????????????????????????????
	bon.info3 <- paste0("== Alpha level is ", alpha, ". ==")

	bonresults <- list(factlabel, bon.info1, bon.info2, bon.info3, bonstat, bontab)
	names(bonresults) <- c(taref, "bon.info1", "bon.info2", "bon.info3", "bonstat", "bontab")
	return(bonresults)
}


# ???????????????????????????
post.analyses <- function(dat, design, factnames = NA, mainresults, type2 = FALSE, nopost = FALSE, holm = FALSE, hc = FALSE, 
	s2r = FALSE, s2d = FALSE, fs1 = FALSE, fs2r = FALSE, fs2d = FALSE, welch = FALSE, criteria = FALSE, 
	lb = FALSE, gg = FALSE, hf = FALSE, cm = FALSE, auto = FALSE, mau = FALSE, har = FALSE, iga = FALSE, ciga = FALSE, 
	eta = FALSE, peta = FALSE, geta = NA, eps = FALSE, peps = FALSE, geps = NA, omega = FALSE, omegana = FALSE, pomega = FALSE, 
	gomega = NA, gomegana = NA, prep = FALSE, nesci = FALSE){
	anovatab <- mainresults$anovatab
	internal.lab <- mainresults$internal.lab

	# ?????????????????????????????????????????????????????????????????????????????????
	bet.with <- strsplit(design, "s")[[1]]

	# ????????????????????????????????????????????????????????????
	# sig.source <- internal.lab[!((anovatab$sig.col == "") | (anovatab$sig.col == "ns"))]
	sig.source <- internal.lab[-c(grep("s", anovatab$source.col), grep("Total", anovatab$source.col))]
	if(length(sig.source) == 0 | nopost){
		return(NA)# ????????????????????????????????????nopost???????????????????????????????????????????????????????????????
	}else{
		# pro.fraction?????????????????????
		postresults <- lapply(sig.source, function(x) pro.fraction(dat = dat, design = design, factnames = factnames, 
			postplan = x, bet.with = bet.with, mainresults = mainresults, type2 = type2, holm = holm, hc = hc, s2r = s2r, 
			s2d = s2d, fs1 = fs1, fs2r = fs2r, fs2d = fs2d, welch = welch, criteria = criteria, lb = lb, gg = gg, hf = hf, 
			cm = cm, auto = auto, mau = mau, har = har, iga = iga, ciga = ciga, eta = eta, peta = peta, geta = geta, eps = eps, 
			peps = peps, geps = geps, omega = omega, omegana = omegana, pomega = pomega, gomega = gomega, gomegana = gomegana, 
			prep = prep, nesci = nesci))
		names(postresults) <- sig.source

		return(postresults)
	}
}


# ??????????????????????????????????????????????????????????????????
pro.fraction <- function(dat, design, factnames = NA, postplan, bet.with, mainresults, type2 = FALSE, holm = FALSE, hc = FALSE, 
	s2r = FALSE, s2d = FALSE, fs1 = FALSE, fs2r = FALSE, fs2d = FALSE, welch = FALSE, criteria = FALSE, 
	lb = FALSE, gg = FALSE, hf = FALSE, cm = FALSE, auto = FALSE, mau = FALSE, har = FALSE, iga = FALSE, ciga = FALSE, 
	eta = FALSE, peta = FALSE, geta = NA, eps = FALSE, peps = FALSE, geps = NA, omega = FALSE, omegana = FALSE, pomega = FALSE, 
	gomega = NA, gomegana = NA, prep = FALSE, nesci = FALSE, esboot = FALSE){
	# ???????????????
	anovatab <- mainresults$anovatab
	mse.row <- mainresults$mse.row
	internal.lab <- mainresults$internal.lab
	flev <- mainresults$flev# ?????????????????????

	# ??????????????????????????????????????????????????????????????????
	sig.term <- as.character(postplan)
	sig.num <- nchar(sig.term)
	sig.source <- as.character(anovatab$source.col[match(sig.term, internal.lab)])

	# ????????????????????????????????????????????????????????????
	if(sig.num > 3){# ???????????????????????????????????????????????????
		highx <- sig.source
		names(highx) <- sig.term
		return(highx)
	}else if(sig.num == 3){# ????????????????????????????????????????????????????????????????????????
		maxfact <- nchar(design) - 1# ???????????????????????????????????????
		spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
		betlen <- spos - 1# ????????????????????????
		withlen <- maxfact - spos + 1# ????????????????????????

		# ???????????????????????????
		each.term <- strsplit(sig.term, ":")[[1]]
		targetnm <- sapply(each.term, function(x) grep(x, LETTERS[1:maxfact]))# ???????????????????????????????????????????????????????????????????????????????????????
		rtargetnm <- sort(targetnm, decreasing = TRUE)# ?????????????????????
		desnm <- c(betlen, withlen)# ????????????????????????????????????????????????????????????????????????
		sublevn <- lapply(LETTERS[rtargetnm], function(x) desnm - diag(2)[grep(x, bet.with), ])# ?????????????????????????????????????????????????????????????????????
		subdesign <- sapply(sublevn, function(x) paste0(paste0(LETTERS[min(1, x[1]):x[1]], collapse = ""), "s", 
			paste0(LETTERS[(x[2] != 0) * (x[1]+1):sum(x)], collapse = "")))# ???????????????????????????????????????
		subdesign <- rep(subdesign, flev[rtargetnm])# ???????????????????????????????????????????????????

		# ??????????????????????????????
		all.lev <- unlist(lapply(rtargetnm + 1, function(x) levels(dat[, x])))# ???????????????????????????????????????????????????????????????????????????
		nmline <- rep(rtargetnm, flev[rtargetnm])# ??????????????????????????????????????????????????????????????????????????????
		tfline <- rep(targetnm, flev[rtargetnm])# ?????????????????????????????????????????????????????????
		subline <- unlist(lapply(rtargetnm + 1, function(x) split(x = seq_len(nrow(dat)), dat[, x])), recursive = FALSE)
		subdat <- mapply(function(x, y) dat[x, -y], subline, nmline + 1, SIMPLIFY = FALSE)
		interlab <- rep(LETTERS[targetnm - 0:1], flev[rtargetnm])
		simtimes <- length(nmline)# ???????????????????????????????????????

		# ????????????????????????????????????????????????????????????
		for(i in 1:simtimes){
			names(subdat[[i]]) <- c("s", LETTERS[1:(maxfact-1)], "y")
		}

		if(withlen == 0){# ??????????????????????????????????????????????????????????????????
			bet.mse <- anovatab[mse.row, ]
			gss.qT <- sum(anovatab$ss.col[-nrow(anovatab)])
			anlefpos <- match(LETTERS[tfline], internal.lab)
			if(!is.null(mainresults$esdenomis)){# ??????????????????????????????
				post.esdenomis <- mainresults$esdenomis[anlefpos, , drop = FALSE]
			}
			if(!is.null(mainresults$es.df.adjs)){# ???????????????????????????????????????????????????
				post.guide <- match(LETTERS[tfline], dimnames(mainresults$es.df.adj)[[1]])
				post.df.adj <- mainresults$es.df.adjs[post.guide, , drop = FALSE]
				post.mse.adj <- mainresults$es.mse.adjs[post.guide, , drop = FALSE]
			}

			# ???????????????
			sim.effects <- lapply(1:simtimes, function(x) anova.modeler(dat = subdat[[x]], design = subdesign[x], 
				factnames = factnames[-nmline[x]], type2 = type2, eta = eta, peta = peta, geta = geta, eps = eps, 
				peps = peps, geps = geps, omega = omega, omegana = omegana, pomega = pomega, gomega = gomega, gomegana = gomegana, 
				prep = prep, nesci = nesci, inter = interlab[x], bet.mse = bet.mse, gss.qT = gss.qT, 
				post.esdenomis = post.esdenomis[x, , drop = FALSE], post.df.adj = post.df.adj[x, , drop = FALSE], 
				post.mse.adj = post.mse.adj[x, , drop = FALSE]))
			simtab <- do.call(rbind, lapply(sim.effects, function(x) x$intertab))
			simepsi <- do.call(rbind, lapply(sim.effects, function(x) x$interepsi))
			simnesci <- do.call(rbind, lapply(sim.effects, function(x) x$nescitab))
			sim.internal.lab <- paste(rep(LETTERS[targetnm], flev[rtargetnm]), all.lev, sep = " at ")
			subbase <- paste(rep(factnames[targetnm], flev[rtargetnm]), all.lev, sep = " at ")

			# ???????????????
			simeflen <- nrow(simtab)/2
			simefpos <- 1:simeflen# ???????????????????????????
			sim.internal.lab <- c(sim.internal.lab, "Error")# ??????????????????????????????
			subsource <- c(subbase, "Error")# ????????????????????????
			simepsi <- NA# ?????????????????????????????????
			simtab <- simtab[c(2 * 1:simeflen - 1, nrow(simtab)), ]

			# ??????????????????????????????????????????MSe?????????
			sim.bet.mse <- replicate(simeflen, bet.mse, simplify = FALSE)
		}else{# ?????????????????????????????????
			# ???????????????
			sim.effects <- lapply(1:simtimes, function(x) anova.modeler(dat = subdat[[x]], design = subdesign[x], 
				factnames = factnames[-nmline[x]], type2 = type2, lb = lb, gg = gg, hf = hf, cm = cm, auto = auto, 
				mau = mau, har = har, iga = iga, ciga = ciga, eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, 
				geps = geps, omega = omega, omegana = omegana, pomega = pomega, gomega = gomega, gomegana = gomegana, 
				prep = prep, nesci = nesci, inter = interlab[x]))
			simtab <- do.call(rbind, lapply(sim.effects, function(x) x$intertab))
			simepsi <- do.call(rbind, lapply(sim.effects, function(x) x$interepsi))
			simnesci <- do.call(rbind, lapply(sim.effects, function(x) x$nescitab))
			sim.internal.lab <- paste(rep(LETTERS[targetnm], flev[rtargetnm]), all.lev, sep = " at ")
			subbase <- paste(rep(factnames[targetnm], flev[rtargetnm]), all.lev, sep = " at ")

			# ???????????????
			simeflen <- nrow(simtab)/2
			simefpos <- 2 * 1:simeflen - 1# ???????????????????????????
			simer <- ifelse(targetnm <= betlen, "Er", paste0("s:", LETTERS[targetnm]))
			suber <- ifelse(targetnm <= betlen, "Er", paste0("s x ", factnames[targetnm]))
			sim.internal.lab <- c(sim.internal.lab, paste0(rep(simer, flev[rtargetnm]), " at ", all.lev))
			sim.internal.lab <- sim.internal.lab[order(c(simefpos, 2 * 1:simeflen))]# ??????????????????????????????
			subsource <- c(subbase, paste0(rep(suber, flev[rtargetnm]), " at ", all.lev))
			subsource <- subsource[order(c(simefpos, 2 * 1:simeflen))]# ????????????????????????
			if(!all(is.na(simepsi))){# ???????????????????????????????????????
				simepsi$Effect <- subsource[simefpos]# subsource?????????????????????simepsi????????????????????????????????????
				simepsi <- simepsi[!is.na(simepsi$df), ]# df???NA?????????????????????????????????????????????
			}

			# ???????????????????????????????????????????????????????????????MSe?????????????????????????????????????????????NA?????????
			sim.bet.mse <- lapply(1:simtimes, function(x){if(tfline[x] <= betlen) simtab[x * 2, ] else NA})
		}

		# ??????????????????????????????????????????????????????
		simtab$source.col <- subsource
		row.names(simtab) <- NULL

		# ?????????????????????????????????????????????????????????????????????
		if(nesci){
			estimes <- nrow(simnesci)/simtimes
			simnesci <- simnesci[order(rep(1:estimes, simtimes)), ]
			simnesci$Source <- rep(subbase, estimes)
		}

		# ????????????????????????
		sim.sncol <- as.vector(tapply(dat$y, dat[, rtargetnm + 1], length))# ????????????????????????????????????
		sim.mncol <- as.vector(tapply(dat$y, dat[, rtargetnm + 1], mean))# ??????????????????????????????
		sim.sdcol <- as.vector(tapply(dat$y, dat[, rtargetnm + 1], sd))# ????????????????????????????????????
		sim.stat <- data.frame("Term1" = rep(levels(dat[, targetnm[1] + 1]), each = flev[rtargetnm[1]]), 
			"Term2" = rep(levels(dat[, targetnm[2] + 1]), flev[rtargetnm[2]]), "n" = sim.sncol, 
			"Mean" = sim.mncol, "S.D." = sim.sdcol)

		# ???????????????????????????
		names(sim.stat)[1:2] <- factnames[targetnm]

		# ????????????????????????????????????????????????
		sim.sig.col <- ((simtab$sig.col != "") & (simtab$sig.col != "ns"))[simefpos] & flev[tfline] >= 3# ????????????????????????????????????
		sim.sig.lab <- simtab$source.col[simefpos]

		# ?????????????????????
		if(sum(sim.sig.col) == 0){
			sim.multresults <- NA# ??????????????????????????????NA?????????
		}else{
			sim.multresults <- lapply((1:length(sim.sig.col))[sim.sig.col], function(x) mod.Bon(dat = subdat[[x]], 
				design = subdesign[x], taref = interlab[x], bet.mse = sim.bet.mse[[x]], factlabel = sim.sig.lab[x], 
				factnames = factnames[-nmline[x]], type2 = type2, holm = holm, hc = hc, s2r = s2r, s2d = s2d, 
				fs1 = fs1, fs2r = fs2r, fs2d = fs2d, welch = welch, criteria = criteria))
		}

		sim.dmat <- lapply(sim.effects, function(x) x$dmat)
		sim.cellN <- sapply(sim.effects, function(x) x$cellN)
		sim.flev <- lapply(sim.effects, function(x) x$flev)
		simresults <- list(sig.source, sim.stat, simepsi, simtab, simnesci, sim.multresults, sim.dmat, sim.cellN, sim.flev)
		names(simresults) <- c(sig.term, "sim.stat", "simepsi", "simtab", "simnesci", "sim.multresults", "sim.dmat", "sim.cellN", "sim.flev")
		return(simresults)
	}else if(sig.num == 1){# ??????????????????????????????????????????????????????????????????????????????
		# ????????????????????????????????????????????????????????????
		col.num <- charmatch(sig.term, names(dat))# ?????????
		level.num <- nlevels(dat[, col.num])# ?????????

		# ??????????????????????????????????????????mod.Bon?????????????????????
		if(level.num >= 3){
			multfact <- grep(sig.term, bet.with[1])# ??????????????????????????????????????????????????????????????????

			# ????????????????????????????????????????????????????????????mod.Bon???????????????????????????
			if(!is.na(multfact[1])){
				if(substr(design, nchar(design), nchar(design)) == "s"){
				# ?????????????????????????????????????????????MS?????????
					bet.mse <- anovatab[charmatch("Error", internal.lab), ]
				}else{
				# ???????????????????????????????????????????????????MS?????????
					f.denomi <- rep(mse.row, c(mse.row[1], diff(mse.row)))
					bet.mse <- anovatab[f.denomi[charmatch(sig.term, internal.lab)], ]
				}
			}else{
				bet.mse <- NA
			}
			bonout <- mod.Bon(dat = dat, design = design, taref = sig.term, bet.mse = bet.mse, factlabel = sig.source, 
				factnames = factnames, type2 = type2, holm = holm, hc = hc, s2r = s2r, s2d = s2d, fs1 = fs1, fs2r = fs2r, 
				fs2d = fs2d, welch = welch, criteria = criteria)
			return(bonout)
		}else{
			return(NA)# ?????????????????????NA?????????
		}
	}
}


# ???????????????????????????????????????????????????????????????????????????????????????
# BCa???????????????
boot.esci <- function(dat, design, factnames = NA, type2 = FALSE, nopost = FALSE, mainresults = NULL, postresults = NULL, 
	lb = FALSE, gg = FALSE, hf = FALSE, cm = FALSE, auto = FALSE, mau = FALSE, har = FALSE, iga = FALSE, ciga = FALSE, 
	eta = FALSE, peta = FALSE, geta = NA, eps = FALSE, peps = FALSE, geps = NA, omega = FALSE, omegana = FALSE, pomega = FALSE, 
	gomega = NA, gomegana = NA, prep = FALSE, interim = FALSE, B = 2000, conf.level = 0.95){
	# ??????????????????????????????????????????
	if(sum(c(eta, peta, geta, eps, peps, geps, omega, omegana, pomega, gomega, gomegana), na.rm = TRUE) == 0){
		warning("Please specify some effect sizes to be bootstrapped for their confidence intervals...")
		return(NA)
	}

	maxfact <- nchar(design) - 1# ???????????????????????????????????????
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????
	uniq.s <- unique(dat$s)

	# factnames????????????????????????????????????????????????????????????????????????
	if(anyNA(factnames)) factnames <- LETTERS[1:maxfact]

	# ??????????????????????????????
	if(is.null(mainresults)){
		mainresults <- anova.modeler(dat = dat, design = design, factnames = factnames, type2 = type2, 
			lb = lb, gg = gg, hf = hf, cm = cm, auto = auto, mau = mau, har = har, iga = iga, ciga = ciga, 
			eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, 
			pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep)
	}
	if(is.null(postresults)){
		postresults <- post.analyses(dat = dat, design = design, factnames = factnames, mainresults = mainresults, type2 = type2, 
			nopost = nopost, lb = lb, gg = gg, hf = hf, cm = cm, auto = auto, mau = mau, har = har, iga = iga, ciga = ciga, 
			eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, 
			pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep)
	}
	eslen <- ncol(mainresults$anovatab) - 7# ??????????????????????????????
	estype <- names(mainresults$anovatab)[-(1:7)]# ?????????????????????????????????
	labpos <- c(mainresults$mse.row, nrow(mainresults$anovatab))
	sourcelab <- rep(as.character(mainresults$anovatab$source.col[-labpos]), eslen)# ??????????????????
	es.sample <- unlist(mainresults$anovatab[-labpos, -(1:7)])
	essamlen <- length(es.sample)/eslen# ????????????????????????????????????
	es.sample <- array(es.sample, c(eslen * essamlen, 1))
	eslab <- rep(estype, each = essamlen)# ?????????????????????
	internal.lab <- mainresults$internal.lab
	dmat <- mainresults$dmat
	flev <- mainresults$flev
	cellN <- mainresults$cellN
	full.elem <- mainresults$full.elem
	epsi.effect <- mainresults$epsi.effect
	if(auto){
		autov <- list((mainresults$epsitab$p >= 0.10)[min(withlen, 2):nrow(mainresults$epsitab)])# auto????????????????????????????????????????????????????????????
	}else{
		autov <- NULL
	}

	sig.source <- names(postresults)
	int.sig.source <- sig.source[nchar(sig.source) == 3]# ?????????????????????????????????
	if(length(int.sig.source) > 0){# ??????????????????????????????????????????
		sim.dmat <- lapply(int.sig.source, function(x) postresults[[x]]$sim.dmat)
		sim.flev <- lapply(int.sig.source, function(x) postresults[[x]]$sim.flev)
		sim.cellN <- lapply(int.sig.source, function(x) postresults[[x]]$sim.cellN)
		postype <- lapply(int.sig.source, function(x) sum(is.na(postresults[[x]]$simepsi)) == 1)# ????????????????????????TRUE
		simtabs <- lapply(int.sig.source, function(x) postresults[[x]]$simtab)# ??????????????????????????????
		simsource <- mapply(function(x, y){if(x) y[-nrow(y), 1] 
			else y[-(2 * 1:(nrow(y)/2)), 1]}, postype, simtabs, SIMPLIFY = FALSE)
		es.sims <- unlist(mapply(function(x, y){if(x) y[-nrow(y), -(1:7)] 
			else y[-(2 * 1:(nrow(y)/2)), -(1:7)]}, postype, simtabs, SIMPLIFY = FALSE))
		es.sims <- array(es.sims, c(length(es.sims), 1))
		es.sample <- rbind(es.sample, es.sims)
		essimlen <- sapply(simsource, length)# ??????????????????????????????????????????
		sourcelab <- c(sourcelab, unlist(lapply(simsource, function(x) rep(x, eslen))))
		eslab <- c(eslab, unlist(lapply(essimlen, function(x) rep(estype, each = x))))
		essamlen <- c(essamlen, essimlen)
		if(auto) autov <- c(autov, lapply(int.sig.source, function(x) postresults[[x]]$simepsi$p >= 0.10))
	}else{# ?????????????????????????????????????????????
		sim.dmat <- NULL
		sim.flev <- NULL
		sim.cellN <- NULL
		essimlen <- 0
	}

	# ????????????????????????????????????????????????
	gmat <- array(t(sapply(uniq.s, function(x) (1:nrow(dat))[dat$s == x])), c(cellN, nrow(dat)/cellN))
	if(betlen == 0){
		gmat <- list(gmat)
	}else{
		gsep <- as.numeric(interaction(dat[sort(uniq.s), (betlen+1):2]))
		gmat <- lapply(unique(gsep), function(x) gmat[gsep == x, , drop = FALSE])
	}
	dpart <- dat[, -(maxfact+2)]

	# ??????????????????????????????
	bootdat <- lapply(1:B, function(w) cbind(dpart, y = dat$y[as.vector(do.call(rbind, lapply(gmat, function(x) x[sample(nrow(x), 
		replace = TRUE), , drop = FALSE])))]))
	stm <- Sys.time()# ???????????????????????????????????????
	if(.Platform$GUI == "Rgui"){# Windows???Rgui??????????????????????????????????????????
		bootresults <- do.call(cbind, lapply(1:B, function(v) {
			boot.anova(dat = bootdat[[v]], design = design, factnames = factnames, type2 = type2, dmat = dmat, flev = flev, 
				cellN = cellN, full.elem = full.elem, epsi.effect = epsi.effect, internal.lab = internal.lab, 
				int.sig.source = int.sig.source, sim.dmat = sim.dmat, sim.flev = sim.flev, sim.cellN = sim.cellN, 
				lb = lb, gg = gg, hf = hf, cm = cm, autov = autov, mau = mau, har = har, iga = iga, ciga = ciga, 
				eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, 
				pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep)
			}))
		cat("\n", as.numeric(Sys.time() - stm, units = "secs"), " secs elapsed for bootstrapping.", "\n", "\n", sep = "")
	}else{# ????????????IDE?????????????????????????????????????????????
		cat("Now Bootstrapping...", "\n")
		bootresults <- do.call(cbind, lapply(1:B, function(v) {
			if(v %% (B/20) == 0) cat("|", rep("=", ceiling(v/(B/50))), rep(" ", 50 - ceiling(v/(B/50))), "| ", 2 * v/(B/50), "%", "\n", sep = "");
			boot.anova(dat = bootdat[[v]], design = design, factnames = factnames, type2 = type2, dmat = dmat, flev = flev, 
				cellN = cellN, full.elem = full.elem, epsi.effect = epsi.effect, internal.lab = internal.lab, 
				int.sig.source = int.sig.source, sim.dmat = sim.dmat, sim.flev = sim.flev, sim.cellN = sim.cellN, 
				lb = lb, gg = gg, hf = hf, cm = cm, autov = autov, mau = mau, har = har, iga = iga, ciga = ciga, 
				eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, 
				pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep)
			}))
		cat("\n", "Completed! ", as.numeric(Sys.time() - stm, units = "secs"), " secs elapsed.", "\n", "\n", sep = "")
	}

	# ???????????????????????????
	jkresults <- do.call(cbind, lapply(uniq.s, function(x) boot.anova(dat = dat[dat$s != x, ], design = design, 
		factnames = factnames, type2 = type2, flev = flev, cellN = cellN-1, full.elem = full.elem, epsi.effect = epsi.effect, 
		internal.lab = internal.lab, int.sig.source = int.sig.source, lb = lb, gg = gg, hf = hf, cm = cm, autov = autov, 
		mau = mau, har = har, iga = iga, ciga = ciga, eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, 
		omega = omega, omegana = omegana, pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep)))
	jkmeans <- rowMeans(jkresults, na.rm = TRUE)

	# BCa?????????????????????????????????
	bca.z0 <- qnorm(rowSums(bootresults < as.vector(es.sample), na.rm = TRUE) / B)
	bca.a <- rowSums((jkmeans - jkresults)^3, na.rm = TRUE) / (6 * rowSums((jkmeans - jkresults)^2, na.rm = TRUE)^(3/2))
	bca.ci.low <- pnorm(bca.z0 + (bca.z0 + qnorm((1 - conf.level)/2)) / (1 - bca.a * (bca.z0 + qnorm((1 - conf.level)/2))))
	bca.ci.up <- pnorm(bca.z0 + (bca.z0 + qnorm((1 + conf.level)/2)) / (1 - bca.a * (bca.z0 + qnorm((1 + conf.level)/2))))

	# ?????????????????????
	bescitab <- data.frame("ES" = eslab, "Source" = sourcelab, "Observed" = es.sample, 
		"CI_L" = sapply(1:length(bca.ci.low), function(x) quantile(bootresults[x, ], bca.ci.low[x], na.rm = TRUE)), 
		"CI_U" = sapply(1:length(bca.ci.up), function(x) quantile(bootresults[x, ], bca.ci.up[x], na.rm = TRUE)), 
		"Bias" = rowMeans(bootresults, na.rm = TRUE) - es.sample, "S.E." = apply(bootresults, 1, sd), row.names = NULL)
	bescitab <- split(bescitab, rep(1:length(essamlen), eslen * essamlen))
	besci.info1 <- c("=== Bias-Corrected and Accelerated (BCa) Confidence Intervals for ESs ===", 
		paste0("=== ", 100 * conf.level, "% confidence intervals based on ", B, " replications ==="))
	minN <- min(table(dat[, 2:(maxfact+1)]))
	if(minN < 5){# ??????????????????????????????????????????????????????
		besci.info1 <- c(besci.info1, "*** CAUTION! The results may be INVALID because of too small sample size (n < 5). ***")
	}else if(minN < 20){
		besci.info1 <- c(besci.info1, "*** CAUTION! The results should be addressed CAREFULLY because of small sample size (n < 20). ***")
	}
	if(interim){# ?????????????????????????????????
		return(list("besci.info" = besci.info1, "bescitab" = bescitab, "bootresults" = bootresults))
	}else{
		return(list("besci.info" = besci.info1, "bescitab" = bescitab))
	}
}


# ?????????????????????????????????????????????????????????????????????????????????
# ???????????????dat???design???internal.lab???int.sig.source????????????????????????????????????????????????
boot.anova <- function(dat, design, factnames = NA, type2 = FALSE, dmat = NULL, flev = NULL, cellN = NULL, full.elem = NA, 
	epsi.effect = NA, sim.dmat = NULL, sim.flev = NULL, sim.cellN = NULL, mainresults = NA, postresults = NA, internal.lab = NA, 
	int.sig.source = NA, lb = FALSE, gg = FALSE, hf = FALSE, cm = FALSE, autov = NULL, mau = FALSE, har = FALSE, 
	iga = FALSE, ciga = FALSE, eta = FALSE, peta = FALSE, geta = NA, eps = FALSE, peps = FALSE, geps = NA, omega = FALSE, 
	omegana = FALSE, pomega = FALSE, gomega = NA, gomegana = NA, prep = FALSE){
	bet.with <- strsplit(design, "s")[[1]]
	maxfact <- nchar(design) - 1
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????
	if(is.null(flev)) flev <- sapply(2:nchar(design), function(x) length(unique(dat[, x])))# ?????????????????????

	esmain <- anova.modeler(dat = dat, design = design, factnames = factnames, type2 = type2, dmat = dmat, flev = flev, cellN = cellN, 
		full.elem = full.elem, epsi.effect = epsi.effect, lb = lb, gg = gg, hf = hf, cm = cm, auto = auto, autov = autov[[1]], 
		mau = mau, har = har, iga = iga, ciga = ciga, eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, 
		omega = omega, omegana = omegana, pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep, esboot = TRUE)

	if(length(int.sig.source) > 0){# ?????????????????????????????????????????????
		esposts <- lapply(1:length(int.sig.source), function(x) boot.inter(dat = dat, design = design, factnames = factnames, 
			sig.term = int.sig.source[x], bet.with = bet.with, esmain = esmain, type2 = type2, flev = flev, 
			sim.dmat = sim.dmat[[x]], sim.flev = sim.flev[[x]], sim.cellN = sim.cellN[[x]], internal.lab = internal.lab, 
			lb = lb, gg = gg, hf = hf, cm = cm, autov = autov[[x+1]], mau = mau, har = har, iga = iga, ciga = ciga, 
			eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, 
			pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep))
	}else{# ?????????????????????????????????????????????
		esposts <- NULL
	}

	esmat <- c(esmain$eslist, unlist(esposts))
	return(esmat)
}


# ???????????????????????????????????????????????????????????????
boot.inter <- function(dat, design, factnames = NA, type2 = FALSE, dmat = NULL, flev = NULL, cellN = NULL, full.elem = NA, epsi.effect = NA, 
	sim.dmat = NULL, sim.flev = NULL, sim.cellN = NULL, esmain = NA, sig.term = NA, bet.with = NA, internal.lab = NA, 
	lb = FALSE, gg = FALSE, hf = FALSE, cm = FALSE, autov = autov, mau = FALSE, har = FALSE, iga = FALSE, ciga = FALSE, 
	eta = FALSE, peta = FALSE, geta = NA, eps = FALSE, peps = FALSE, geps = NA, omega = FALSE, omegana = FALSE, pomega = FALSE, 
	gomega = NA, gomegana = NA, prep = FALSE){
	maxfact <- nchar(design) - 1# ???????????????????????????????????????
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????

	# ???????????????????????????
	each.term <- strsplit(sig.term, ":")[[1]]
	targetnm <- sapply(each.term, function(x) grep(x, LETTERS[1:maxfact]))# ???????????????????????????????????????????????????????????????????????????????????????
	rtargetnm <- sort(targetnm, decreasing = TRUE)# ?????????????????????
	desnm <- c(betlen, withlen)# ????????????????????????????????????????????????????????????????????????
	sublevn <- lapply(LETTERS[rtargetnm], function(x) desnm - diag(2)[grep(x, bet.with), ])# ?????????????????????????????????????????????????????????????????????
	subdesign <- sapply(sublevn, function(x) paste0(paste0(LETTERS[min(1, x[1]):x[1]], collapse = ""), "s", 
		paste0(LETTERS[(x[2] != 0) * (x[1]+1):sum(x)], collapse = "")))# ???????????????????????????????????????
	subdesign <- rep(subdesign, flev[rtargetnm])# ???????????????????????????????????????????????????

	# ??????????????????????????????
	nmline <- rep(rtargetnm, flev[rtargetnm])# ??????????????????????????????????????????????????????????????????????????????
	tfline <- rep(targetnm, flev[rtargetnm])# ?????????????????????????????????????????????????????????
	subline <- unlist(lapply(rtargetnm + 1, function(x) split(x = seq_len(nrow(dat)), dat[, x])), recursive = FALSE)
	subdat <- mapply(function(x, y) dat[x, -y], subline, nmline + 1, SIMPLIFY = FALSE)
	interlab <- rep(LETTERS[targetnm - 0:1], flev[rtargetnm])
	simtimes <- length(nmline)# ???????????????????????????????????????
	if(!is.null(autov)) c(rep(T, simtimes - length(autov)), autov)

	# ????????????????????????????????????????????????????????????
	for(i in 1:simtimes){
		names(subdat[[i]]) <- c("s", LETTERS[1:(maxfact-1)], "y")
	}

	if(withlen == 0){# ??????????????????????????????????????????????????????????????????
		bet.mse <- esmain$bet.mse
		gss.qT <- esmain$ss.qT
		anlefpos <- match(LETTERS[tfline], internal.lab)
		if(!is.null(esmain$esdenomis)){# ??????????????????????????????
			post.esdenomis <- esmain$esdenomis[anlefpos, , drop = FALSE]
		}

		# ???????????????
		sim.effects <- lapply(1:simtimes, function(x) anova.modeler(dat = subdat[[x]], design = subdesign[x], 
			factnames = factnames[-nmline[x]], type2 = type2, dmat = sim.dmat[[x]], flev = sim.flev[[x]], cellN = sim.cellN[x], 
			eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, 
			pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep, inter = interlab[x], bet.mse = bet.mse, 
			gss.qT = gss.qT, post.esdenomis = post.esdenomis[x, , drop = FALSE], esboot = TRUE))
		simes <- as.vector(do.call(rbind, sim.effects))
	}else{# ?????????????????????????????????
		# ???????????????
		sim.effects <- lapply(1:simtimes, function(x) anova.modeler(dat = subdat[[x]], design = subdesign[x], 
			factnames = factnames[-nmline[x]], type2 = type2, dmat = sim.dmat[[x]], flev = sim.flev[[x]], cellN = sim.cellN[x], 
			lb = lb, gg = gg, hf = hf, cm = cm, autov = autov[x], mau = mau, har = har, iga = iga, ciga = ciga, 
			eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, omega = omega, omegana = omegana, 
			pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep, inter = interlab[x], esboot = TRUE))
		simes <- as.vector(do.call(rbind, sim.effects))
	}

	return(simes)
}


# ??????????????????????????????????????????????????????
anova.output <- function(maxfact, exe.info, baseresults, mainresults, postresults = NA, sep = " "){
	# ?????????????????????
	cat("\n")
	cat(sprintf(exe.info[1]), sep = "\n")
	cat("\n")
	cat(sprintf(exe.info[2:3]), sep = "\n")
	cat("\n", "\n")

	# ????????????????????????
	bstat.title	<- "<< DESCRIPTIVE STATISTICS >>"
	bstat.info1 <- baseresults$bstat.info1
	bstatist <- baseresults$bstatist
	bstat.info2 <- baseresults$bstat.info2
	pairtab <- baseresults$pairtab
	flev <- mainresults$flev
	if(maxfact < 3){# ?????????????????????
		margin <- prod(flev)
	}else{
		margin <- prod(flev[-(1:(maxfact-2))])
	}
	table.out(bstatist, titleinfo = bstat.title, subinfo1 = bstat.info1, smargin = margin, rndpos = maxfact + 1, sep = sep)
	if(!is.null(pairtab)){# ????????????????????????????????????????????????
		table.out(pairtab, subinfo1 = bstat.info2, sep = sep)
	}
	cat("\n")

	# ???????????????????????????
	epsitab.title <- "<< SPHERICITY INDICES >>"
	epsi.info1 <- mainresults$epsi.info1
	epsitab <- mainresults$epsitab
	epsi.header <- names(epsitab)
	epsi.header[6] <- ""
	if(!is.na(epsi.info1)){# ???????????????????????????????????????
		if(match("GG", names(epsitab), nomatch = 0) != 0){
			epsi.info2 <- c("LB = lower.bound, GG = Greenhouse-Geisser", "HF = Huynh-Feldt-Lecoutre, CM = Chi-Muller")
			epsi.margin <- nrow(epsitab)
		}else{
			epsi.info2 <- "multiplier = b_hat or c_hat"
			epsi.margin <- c(anyNA(epsitab$df) * (1:nrow(epsitab))[!is.na(epsitab$df)] - 1, nrow(epsitab))
		}
		table.out(epsitab, titleinfo = epsitab.title, subinfo1 = epsi.info1, subinfo2 = epsi.info2, lmargin = epsi.margin, 
			use.header = epsi.header, tnick = 0, rndpos = 4, strpos = c(1, 4), na.erase = 5, leftal = 6, sep = sep)
		cat("\n")
	}

	# ????????????????????????
	anovatab.title <- "<< ANOVA TABLE >>"
	ano.info1 <- mainresults$ano.info1
	ano.info2 <- "+p < .10, *p < .05, **p < .01, ***p < .001"
	anovatab <- mainresults$anovatab
	
	forDrawingSigANOVA <<- mainresults$anovatab
	forDrawingPost <<- postresults


	ano.header <- names(anovatab)
	ano.header[1:7] <- c("Source", "SS", "df", "MS", "F-ratio", "p-value", "")
	mse.row <- mainresults$mse.row
	nesci.info1 <- mainresults$nesci.info1
	nescitab <- mainresults$nescitab
	if(length(ano.header) > 7){# ????????????????????????????????????????????????????????????
		ano.nick <- 0
		ano.erase <- c(5:6, 8:length(ano.header))
	}else{
		ano.nick <- 1
		ano.erase <- 5:6
	}
	table.out(anovatab, titleinfo = anovatab.title, subinfo1 = ano.info1, subinfo2 = ano.info2, use.header = ano.header, 
		lmargin = mse.row, tnick = ano.nick, rndpos = 3, na.erase = ano.erase, leftal = 7, sep = sep)
	cat("\n")
	if(!anyNA(nesci.info1)){# ?????????????????????????????????????????????????????????????????????
		esci.title <- "<< EFFECT SIZE INFORMATION >>"
		efrowsize <- nrow(anovatab) - length(mse.row) - 1
		table.out(nescitab, titleinfo = esci.title, subinfo1 = nesci.info1, lmargin = efrowsize * 1:(nrow(nescitab)/efrowsize), 
			sep = sep)
		cat("\n")
	}
	if(match("bescitab", names(mainresults), nomatch = 0) != 0){# ?????????????????????????????????????????????????????????????????????????????????
		if(!anyNA(nesci.info1)){
			esci.title <- NULL
		}else{
			esci.title <- "<< EFFECT SIZE INFORMATION >>"
		}
		efrowsize <- nrow(anovatab) - length(mse.row) - 1
		table.out(mainresults$bescitab, titleinfo = esci.title, subinfo1 = mainresults$besci.info, 
			lmargin = efrowsize * 1:(nrow(mainresults$bescitab)/efrowsize), sep = sep)
		cat("\n")
	}

	# ??????????????????????????????
	postnum <- length(postresults)# ?????????????????????????????????????????????
	# ???????????????????????????NA????????????????????????????????????????????????????????????????????????
	if(sum(is.na(postresults)) != postnum){
		cat(sprintf("<< POST ANALYSES >>"), sep = "", "\n", "\n")# ????????????
	}
	postnames <- names(postresults)
	for(i in 1:postnum){
		if(is.na(postresults[[i]][1])){# ?????????????????????????????????????????????????????????????????????????????????????????????
		}else if(nchar(postnames[i]) == 1){# ????????????????????????????????????
			mod.Bon.out(postresults[[i]], sep = sep)
			cat("\n")# ???????????????
		}else if(nchar(postnames[i]) == 3){# ??????????????????????????????????????????
			if(maxfact == 2){
				simeffects.out(postresults[[i]], epsi.info2 = epsi.info2, epsi.header = epsi.header, ano.info2 = ano.info2, 
					ano.header = ano.header, ano.nick = ano.nick, ano.erase = ano.erase, omit = TRUE, sep = sep)
			}else{
				simeffects.out(postresults[[i]], epsi.info2 = epsi.info2, epsi.header = epsi.header, ano.info2 = ano.info2, 
					ano.header = ano.header, ano.nick = ano.nick, ano.erase = ano.erase, sep = sep)
			}
		}else if(nchar(postnames[i]) >= 5){# ??????????????????????????????????????????
			cat(sprintf(paste0("< HIGHER-ORDER \"", postresults[[i]][[1]], "\" INTERACTION >")),sep = "", "\n")
			cat(sprintf("*** Split the dataset for further analysis. ***"), sep ="", "\n", "\n")# ???????????????????????????????????????
		}
	}

	# ?????????????????????
	cat(sprintf("output is over "), sprintf(rep("-", 20)), sprintf("///"), sep = "", "\n", "\n")
}


# ????????????????????????????????????????????????????????????
# smargin??????????????????????????????lmargin?????????????????????????????????tnick???????????????????????????rndpos????????????????????????????????????
# strpos???????????????????????????????????????na.erase???NA???????????????????????????leftal?????????????????????
table.out <- function(dattable, titleinfo = NULL, subinfo1 = NULL, subinfo2 = NULL, use.header = NULL, smargin = nrow(dattable), 
	lmargin = nrow(dattable), tnick = 1, rndpos = 0, strpos = rndpos, na.erase = NULL, leftal = NULL, sep = " "){
	# ???????????????????????????????????????????????????????????????????????????
	tabline <- pmax(3, sapply(1:ncol(dattable), function(x) ifelse(is.numeric(dattable[, x]), max(nchar(sprintf("%.4f", dattable[, x]), type = "width")), max(nchar(as.character(dattable[, x]), type = "width")))) + tnick)
	if(is.null(use.header)){# ????????????????????????????????????????????????????????????
		tabhead <- nchar(names(dattable)) + 1
	}else{# ???????????????????????????????????????
		tabhead <- nchar(use.header) + 1
	}
	tabline <- ifelse(tabline > tabhead, tabline, tabhead)
	if(rndpos != 0){
		dattable[, rndpos] <- round(dattable[, rndpos], 2)# ????????????????????????????????????????????????????????????
		tabline[rndpos] <- pmax(3, max(nchar(dattable[, rndpos])))
	}
	mainline <- sum(tabline) + length(tabline)
	headmargin <- sapply(tabline, function(x) paste0("%", x, "s"))
	bodymargin <- headmargin
	coltype <- sapply(1:ncol(dattable), function(x) is.factor(dattable[, x]))# ?????????factor??????????????????
	coltype[strpos] <- TRUE# ????????????????????????????????????factor????????????????????????????????????
	bodymargin[!coltype] <- paste0("%", tabline[!coltype], ".4f")# factor??????????????????????????????????????????
	bodymargin[leftal] <- gsub("%", "%-", bodymargin[leftal])# ???????????????????????????

	# ???????????????????????????
	if(!is.null(titleinfo)){# titleinfo???NULL?????????????????????
		cat(sprintf(titleinfo), sep = "", "\n")
		cat("\n")# ???????????????
	}
	if(!is.null(subinfo1)){# subinfo1???NULL?????????????????????
		cat(subinfo1, sep = "\n")# ????????????????????????
		cat("\n")# ???????????????
	}

	# ??????????????????????????????????????????????????????
	cat(sprintf(rep("-", mainline + 2)), sep = "", "\n")# ???????????????????????????????????????????????????????????????
	if(is.null(use.header)){
		cat(sprintf(headmargin, names(dattable)), sep = sep, "\n")# ?????????????????????????????????????????????
	}else{
		cat(sprintf(headmargin, use.header), sep = sep, "\n")# ?????????????????????????????????????????????????????????
	}
	cat(sprintf(rep("-", mainline + 2)), sep = "", "\n")

	# ??????????????????????????????????????????????????????????????????
	for (i in 1:nrow(dattable)){# ??????????????????
		for(j in 1:ncol(dattable)){# ??????????????????
			if(is.element(j, na.erase)){# ??????????????????????????????NA???????????????????????????????????????
				cat(replace(sprintf(bodymargin[j], dattable[i, j]), is.na(dattable[i, j]), sprintf(headmargin[j], "")))
			}else{
				cat(sprintf(bodymargin[j], dattable[i, j]))
			}
			cat(sep, sep = "")
		}
		cat("\n")
		if(is.element(i, lmargin)){# ??????????????????
			cat(sprintf(rep("-", mainline + 2)), sep = "", "\n")
		}
		if((i %% smargin == 0) && (i != nrow(dattable))){# ???????????????
			cat("\n")
		}
	}
	if(!is.null(subinfo2)){# subinfo2???NULL?????????????????????
		cat(sprintf(paste0("%", mainline, "s"), subinfo2), sep = "\n")# ????????????????????????
	}
	cat("\n")# ???????????????
}


# ??????Bonferroni????????????????????????????????????????????????????????????
mod.Bon.out <- function(bon.list, omit = FALSE, sep = " "){
	# ???????????????
	factlabel <- bon.list[[1]]
	bon.info1 <- bon.list[[2]]
	bon.info2 <- bon.list[[3]]
	bon.info3 <- bon.list[[4]]
	bonstat <- bon.list[[5]]
	bontab <- bon.list[[6]]
	Bon.header <- c("Pair", "Diff", "t-value", "df", "p", "adj.p", "")

	cat(sprintf(paste0("< MULTIPLE COMPARISON for \"", factlabel, "\" >")), sep = "", "\n", "\n")# ????????????
	cat(sprintf(bon.info1), sep = "\n")# ???????????????
	cat(sprintf(bon.info2), "\n")
	cat(sprintf(bon.info3), "\n", "\n")

	# omit???FALSE????????????????????????????????????
	if(!omit){
		table.out(bonstat, rndpos = 2, sep = sep)
	}

	# ????????????????????????????????????????????????
	table.out(bontab, use.header = Bon.header, rndpos = 4, strpos = c(1, 4), sep = sep)
}


# ??????????????????????????????????????????????????????
simeffects.out <- function(partresult, epsi.info2 = NA, epsi.header = NA, ano.info2 = NA, ano.header = NA, ano.nick = NA, 
	ano.erase = NA, omit = FALSE, sep = " "){
	# ???????????????
	part.info1 <- partresult[[1]]
	partstat <- partresult$sim.stat
	partepsi <- partresult$simepsi
	parttab <- partresult$simtab
	partmulttab <- partresult$sim.multresults
	partnesci <- partresult$simnesci

	cat(sprintf("%s", paste0("< SIMPLE EFFECTS for \"", part.info1, "\" INTERACTION >"), sep = ""), sep = "", "\n", "\n")# ????????????

	# omit???FALSE????????????????????????????????????
	if(!omit){
		table.out(partstat, rndpos = 3, sep = sep)
	}

	# ?????????????????????????????????
	if(is.na(charmatch("Error", parttab$source.col)) && !is.na(partepsi)){
		# ????????????????????????????????????????????????????????????????????????????????????
		table.out(partepsi, subinfo2 = epsi.info2, use.header = epsi.header, tnick = c(1, rep(0, length(epsi.header) - 1)), 
			rndpos = 4, strpos = c(1, 4), na.erase = 5, leftal = 6, sep = sep)
		efrowsize <- nrow(parttab)/2
		linepos <- 2 * 1:(nrow(parttab)/2)
	}else{
		efrowsize <- nrow(parttab) - 1
		linepos <- nrow(parttab)
	}

	# ????????????????????????
	table.out(parttab, subinfo2 = ano.info2, use.header = ano.header, lmargin = linepos, tnick = ano.nick, rndpos = 3, 
		strpos = c(1, 3), na.erase = ano.erase, leftal = 7, sep = sep)
	if(!all(is.na(partnesci))){# ?????????????????????????????????????????????????????????????????????
		table.out(partnesci, lmargin = efrowsize * 1:(nrow(partnesci)/efrowsize), strpos = 2, sep = sep)
		cat("\n")
	}
	if(match("bescitab", names(partresult), nomatch = 0) != 0){# ?????????????????????????????????????????????????????????????????????????????????
		table.out(partresult$bescitab, lmargin = efrowsize * 1:(nrow(partresult$bescitab)/efrowsize), strpos = 2, sep = sep)
		cat("\n")
	}

	# ????????????????????????????????????
	for (i in 1:length(partmulttab)){
		if(!is.na(partmulttab[[i]][1])){# ?????????????????????????????????????????????
			cat("\n")# ???????????????
			mod.Bon.out(partmulttab[[i]], omit = TRUE, sep = sep)
		}
	}
}


# ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# tfact??????????????????????????????????????????????????????????????????????????????tfact = "A"?????????
# ?????????????????????????????????????????????????????????tfact = c("A", "C")?????????????????????????????????
anovatan <- function(dataset, design, ..., tfact = NULL, long = FALSE, type2 = FALSE, nopost = FALSE, tech = FALSE, data.frame = FALSE, copy = FALSE, 
	holm = FALSE, hc = FALSE, s2r = FALSE, s2d = FALSE, fs1 = FALSE, fs2r = FALSE, fs2d = FALSE, welch = FALSE, criteria = FALSE, 
	lb = FALSE, gg = FALSE, hf = FALSE, cm = FALSE, auto = FALSE, mau = FALSE, har = FALSE, iga = FALSE, ciga = FALSE, 
	eta = FALSE, peta = FALSE, geta = NA, eps = FALSE, peps = FALSE, geps = NA, omega = FALSE, omegana = FALSE, pomega = FALSE, 
	gomega = NA, gomegana = NA, prep = FALSE, nesci = FALSE, besci = FALSE, cilmd = FALSE, cilm = FALSE, cind = FALSE, cin = FALSE, ciml = FALSE, 
	cipaird = FALSE, cipair = FALSE, bgraph = c(NA, NA)){
	# ????????????????????????????????????????????????????????????
	if(is.null(tfact)){
		stop(message = "\"anovatan\" has stopped working...\nPlease specify some factors to split.")
	}

	# ???????????????????????????
	maxfact <- nchar(design) - 1# ???????????????????????????????????????
	bet.with <- strsplit(design, "s")[[1]]
	spos <- match("s", strsplit(design, "")[[1]], nomatch = 0)
	betlen <- spos - 1# ????????????????????????
	withlen <- maxfact - spos + 1# ????????????????????????

	# ??????????????????????????????
	datform <- uni.long(dataset = dataset, design = design, ... = ..., long = long)
	dat <- datform$dat
	factnames <- datform$factnames
	miscase <- datform$miscase
	names(dat) <- c("s", factnames, "y")
	targetnm <- sapply(tfact, function(x) grep(x, factnames))# ???????????????????????????????????????????????????????????????????????????????????????

	# ?????????????????????????????????
	subdat <- split(dat, dat[, tfact])# ??????????????????????????????
	whichfact <- sapply(LETTERS[targetnm], function(x) grep(x, bet.with))# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????
	bet.withN <- c(betlen, withlen) - c(sum(whichfact == 1), sum(whichfact == 2))# ??????????????????????????????????????????????????????????????????????????????????????????
	subdesign <- paste0(paste0(LETTERS[(1 * (bet.withN[1] != 0)):bet.withN[1]], collapse = ""), "s", paste0(LETTERS[1 * (bet.withN[2] != 0) * (bet.withN[1]+1:bet.withN[2])], collapse = ""))# ???????????????????????????

	# copy???????????????????????????????????????????????????????????????????????????????????????
	if(copy){
		plat.info <- .Platform
		if(sum(grep("windows", plat.info)) != 0){# Windows?????????
			sink("clipboard", split = TRUE)
		}else if(sum(grep("mac", plat.info)) != 0){# Mac?????????
			tclip <- pipe("pbcopy", "w")
			sink(tclip, split = TRUE)
		}else if(sum(grep("linux", R.version$system)) != 0){# Linux????????????xclip???????????????????????????????????????????????????
			tclip <- pipe("xclip -selection clipboard")
			sink(tclip, split = TRUE)
		}
	}

	# ??????????????????????????????
	if(miscase != 0){
		cat("[[ Information for Whole Analysis ]]", "\n")
		cat(paste0("== The number of removed case is ", miscase, ". =="), "\n", "\n")
	}

	# anovakun?????????
	for(i in 1:length(subdat)){
		cat("\n", sprintf(paste0("[[ Simple Effects for ", names(subdat)[i], " ]]")), "\n", sep = "")
		anovakun(dataset = subdat[[i]][, -(targetnm + 1)], design = subdesign, long = TRUE, type2 = type2, nopost = nopost, 
			tech = tech, data.frame = FALSE, copy = FALSE, holm = holm, hc = hc, s2r = s2r, s2d = s2d, fs1 = fs1, fs2r = fs2r, 
			fs2d = fs2d, welch = welch, criteria = criteria, lb = lb, gg = gg, hf = hf, cm = cm, auto = auto, mau = mau, 
			har = har, iga = iga, ciga = ciga, eta = eta, peta = peta, geta = geta, eps = eps, peps = peps, geps = geps, 
			omega = omega, omegana = omegana, pomega = pomega, gomega = gomega, gomegana = gomegana, prep = prep, nesci = nesci, besci = besci, 
			cilmd = cilmd, cilm = cilm, cind = cind, cin = cin, ciml = ciml, cipaird = cipaird, cipair = cipair, bgraph = bgraph)
	}

	# copy???????????????????????????????????????????????????????????????
	if(copy){
		sink()
		if(plat.info$OS.type != "windows"){# Mac???Linux?????????
			close(tclip)
		}
	}

	# ????????????????????????????????????????????????????????????????????????
	if(data.frame == TRUE){
		return(subdat)
	}
}

